---
author: GedRelay
Email: gedrelay@stu.jnu.edu.cn
title: 算法-新
time: 2024-02-10 23:37
aliases:
  - suanfa
Description: 
tags: 
lastEdit: 2025-03-06-13:05
---

```toc
style: number
max_depth: 3
```

# 小技巧
## 数据范围反推复杂度及算法
一般 ACM 或者笔试题的时间限制是1秒或2秒。在这种情况下，C++代码中的操作次数控制在 ${10^{7} \sim 10^{8}  }$ 为最佳
下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：
1. ${n\leq 30 }$ =>指数级别，dfs+减枝，状态压缩 dp
2. ${n\leq 100 }$ => ${O\left( n^{3}  \right)  }$，floyd，dp，高斯消元
3. ${n\leq 1000 }$ => ${O\left( n^{2}  \right)  }$，${O\left( n^{2} \log n \right)  }$，dp，二分，朴素版 Dijkstra，朴素版 Prim，Bellman-Ford
4. ${n\leq 1e4 }$ => ${O\left( n\sqrt{ n }  \right)  }$，块状链表，分块，莫队
5. ${n\leq 1e5 }$ => ${O\left( n\log n \right)  }$ ，排序，线段树，树状数组，set，map，heap，拓扑排序，dijkstra+heap，prim+heap，Kruskal，spfa，求凸包，求半平面交，二分，CDQ 分治，整体二分，后缀数组，树链剖分、动态树
6. ${n\leq 1e6 }$ => ${O\left( n \right)  }$，以及常数较小的 ${O\left( n\log n \right)  }$ 算法，单调队列， hash，双指针扫描，BFS，并查集，kmp，AC 自动机，常数较小的 ${O\left( n\log n \right)  }$ 做法：sort，树状数组，heap，dijkstra，spfa
7. ${n\leq 1e7 }$ => ${O\left( n \right)  }$，双指针扫描，kmp，AC 自动机，线性筛素数
8. ${n\leq 1e9 }$ => ${O\left( \sqrt{ n }  \right)  }$，判断素数
9. ${n\leq 1e18 }$ => ${O\left( \log n \right)  }$，最大公约数，快速幂，数位 DP
10. ${n\leq 1e1000 }$ => ${O\left( \left( \log n \right) ^{2}  \right)  }$，高精度加减乘除
11. ${n\leq 1e100000 }$ => ${O\left( \log k\times \log \log k \right)  }$，${k }$ 表示数位，高精度加减，FFT/NTT

## 读取
读取输入速度：
快读 > 优化的 cin > scanf () > cin
快读
```cpp
int read(){
	int x = 0, f = 1;
	char c = getchar();
	while (c<'0' || c>'9'){
		if (c == '-')  f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ '0'), c = getchar();
	return x * f;
}
```
`cin` 优化
```cpp
ios::sync_with_stdio(false);
cin.tie(nullptr);
```
文件读写
```cpp
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
```


## 二进制位运算
与：`&` 
或：`|` 
非：`!` 
异或：`^` 
取反：`~` 
左移：`<<` 
右移：`>>` 

### 常见优化
${x\times 2^{i}   }$ 
```cpp
x << i
```
${x \div2^{i}  }$ 
```cpp
x >> i
```
二进制下 ${x }$ 的第 ${k }$ 位数字（从 ${0 }$ 开始）
```cpp
x >> k & 1 // >>的优先级比&高
```
判断奇偶
```cpp
if(x & 1)
```
找到大于等于 ${n }$ 的最小的二某次方
```cpp
int near2power(int n){
	if(n <= 0) return 1;
	n--;
	n |= n >> 1;
	n |= n >> 2;
	n |= n >> 4;
	n |= n >> 8;
	n |= n >> 16;
	return n + 1;
}
```

题目：
[acwing 801. 二进制中 1 的个数](https://www.acwing.com/problem/content/803/) 
[力扣 190. 颠倒二进制位](https://leetcode.cn/problems/reverse-bits/) 
[力扣 461. 汉明距离](https://leetcode.cn/problems/hamming-distance/) 

### lowbit
提取最右侧的 ${1 }$ 
如 ${lowbot\left( 10010100 \right)  =00000100}$
```cpp
int lowbit(int x){
	return x & -x;
}
```
[力扣 231. 2 的幂](https://leetcode.cn/problems/power-of-two/) 

### 异或
1. 一个数与其自身异或等于 ${0 }$：${x\oplus x=0 }$ 
2. 一个数与 ${0 }$ 异或等于其自身：${x\oplus0=x }$ 

${0,1 }$ 切换
```cpp
x ^= 1;
```
交换两个数 ${a,b }$ 的值，注意其内存地址要求不同。知道写法即可，并不推荐该写法
```cpp
a = a ^ b
b = a ^ b
a = a ^ b
```
字母大小写切换
```cpp
char c = 'a';
c ^= 32; // 小写切换为大写
c ^= 32; // 大写切换为小写
```

找到缺失的数字：所有 ${0\sim n }$ 的数中缺少了一个数字，找到缺失的那个数字
思路：将 ${0\sim n }$ 的数全部异或一遍，再把没有缺失的数异或一遍，就找到了缺失的数字
```cpp
int xorSum = 0;
for(int x = 0; x <= n; x++) xorSum ^= x;
for(int i = 0; i < n; i++) xorSum ^= a[i];
```
[力扣 268. 丢失的数字](https://leetcode.cn/problems/missing-number/) 

找到唯一出现奇数次的数：数组中除了一个数出现奇数次以外，其他所有数全部出现偶数次，求出现奇数次的那个数
思路：将所有数字全部异或一遍
```cpp
int xorSum = 0;
for(int i = 0; i < n; i++) xorSum ^= a[i];
```
[力扣 136. 只出现一次的数字](https://leetcode.cn/problems/single-number/) 

找到唯二出现奇数次的数：数组中除了两个数出现奇数次以外，其他所有数全部出现偶数次，求出现奇数次的那两个数
思路：将所有数进行异或得到 ${a\oplus b }$，再使用 `lowbit(a^b)` 操作得到 ${a }$ 与 ${b }$ 最低位不同的那一位。将原数组按照该位进行分组，再分别求异或和即可分别得到 ${a,b }$ 
```cpp
int xorSum = 0;
for(int x : arr) xorSum ^= x;
rightBit = xorSum & -xorSum; // lowbit()操作
int a = 0, b = 0;
for(int x: arr){
	if(x & rightBit) a ^= x;
	else b ^= x;
}
```
[力扣 260. 只出现一次的数字 III](https://leetcode.cn/problems/single-number-iii/) 

### 比特位计数
找到出现次数少于 ${m }$ 次的数：数组中只有一种数出现次数少于 ${m }$ 次，其他数都出现了 ${m }$ 次，找到出现次数小于 ${m }$ 次的那个数
思路：统计每个位 ${1 }$ 出现的次数，如果该位出现 ${1 }$ 的次数不是 ${m }$ 的倍数（对 ${m }$ 取模结果不为 ${0 }$），那么所求数在该位的值为 ${1 }$ 
```cpp
int cnt[32] = {0};
for(int x : nums){
    for(int i = 0; i < 32; i++){
        cnt[i] += (x >> i) & 1;
    }
}

int ans = 0;
for(int i = 0; i < 32; i++){
    if(cnt[i] % m != 0){
        ans |= (1 << i);
    }
}
```
[力扣 137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/) 




# STL 数据结构

## c++字符串 string
初始化
```cpp
string s = "abc";
string s(6, '#'); // ######
```
整行输入
```cpp
getline(cin, str);
```
访问字符
```cpp
// 使用[]访问
s[idx];
// at 下标访问，越界检测，如果越界抛出错误 std::out_of_range
s.at(idx);
```
翻转字符串
```cpp
reverse(s.begin(), s.end());
```
插入字符串
```cpp
// 在位置pos之前插入str字符串,并返回这个字符串
s.insert(pos, str);
```
截取子串
```cpp
// 截取字符串s，从第pos个位置开始len个字符，并返回这个字符串
s.substr(pos, len)
```
删除子串
```cpp
// 删除从位置pos开始的len个字符,如果len被省略, 则删除从pos开始直至s末尾的所有字符
s.erase(pos, len);
```
查找子串，时间复杂度 ${O\left( nm \right)  }$ 
```cpp
// 在字符串s中从第pos个字符开始寻找str，并返回位置，如果找不到返回string::npos即-1。pos默认为0
s.find(str,[pos])
```
前后缀判断
```cpp
string s = "hello";
bool res1 = s.start_with("hel"); // true
bool res2 = s.end_with("llo"); // true
```
string 转换为其他类型
```cpp
// stoi 字符串转int
string str = "123";
int x = stoi(str); // 123

// stoll 字符串转longlong
string str = "12345678901";
long long x = stoll(str); //12345678901

// stod 字符串转double
string str = "1e4";
double d = stod(str); // 10000

// s.c_str()返回C语言的字符串，注意使用的是同一内存，修改s也会造成cstr修改
const char* cstr = s.c_str();
```
其他类型转换为 string
```cpp
// 使用to_string将int转string
int i = 123;
string s = to_string(i); // "123"

// 使用to_string将double转string
double d = 1e9;
string s = to_string(d); // "1000000000.000000"
string s = format("d = {:.0f}", d) // "d = 1000000000"
```

判断字符类别的函数
![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202502211813868.png)

题目：
[洛谷 P5015 标题统计]( https://www.luogu.com.cn/problem/P5015 ) 
[洛谷 P5733 自动修正](https://www.luogu.com.cn/problem/P5733) 
[洛谷 P1914 小书童——凯撒密码](https://www.luogu.com.cn/problem/P1914) 
[洛谷 P1308 统计单词数]( https://www.luogu.com.cn/problem/P1308 ) 
[洛谷 P5734  文字处理软件](https://www.luogu.com.cn/problem/P5734) 
[洛谷 P1098 字符串的展开]( https://www.luogu.com.cn/problem/P1098 ) 
[力扣 2810. 故障键盘](https://leetcode.cn/problems/faulty-keyboard/) 
[力扣 125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/) 
[acwing 760. 字符串长度](https://www.acwing.com/problem/content/762/) 
[acwing 5272. 字符串中的字母个数](https://www.acwing.com/problem/content/5275/) 
[力扣 2129. 将标题首字母大写](https://leetcode.cn/problems/capitalize-the-title/) 


## 字符串流 stringstream
常用来分割单词（以空格为分割符）
头文件：`include<sstream>` 
```cpp
string line, word;
getline(cin, line);  // 输入一整行数据
stringstream ss(line); // 定义字符串流
while(ss >> word){
    word为line经过空格分隔后所得到的每个字符串
    // 处理word
}
ss.clear()//清除ss的内容，ss还可以再利用
ss.str(data2);  // 重新装载字符串
```

题目：
[力扣 434. 字符串中的单词数](https://leetcode.cn/problems/number-of-segments-in-a-string/) 


## 变长数组（向量） vector
头文件：`include<vector>` 
定义/初始化
```cpp
vector<类型> a;
vector<类型> a(N, i); // a数组一开始有N个元素，每个元素初始化为i
vector<int> a = {1, 2, 3, 4, 5};

vector<vector<int>> a(n, vector<int>(m, 0)); // 定义一个n * m的数组
```
访问元素 ${O\left( 1 \right)  }$ 
```cpp
// 下标从0开始
a[idx];
// 通过 at 来访问元素，有越界检测，越界会抛出 std::out_of_range 异常
a.at(idx);
// 第一个元素
a.front();
// 最后一个元素
a.back();
```
添加元素 ${O\left( 1 \right)  }$ 
```cpp
a.push_back(x);
```
删除最后一个元素 ${O\left( 1 \right)  }$ 
```cpp
a.pop_back();
```
元素个数 ${O\left( 1 \right)  }$ 
```cpp
a.size();
```
判断是否为空 ${O\left( 1 \right)  }$ 
```cpp
a.empty();
```
重新调整数组元素个数
```cpp
// 重新调整数组元素个数为 n
// 若原来长度比 n 大，则删去多余元素
// 若原来长度小于 n，新增部分都为 m
a.resize(n, m);
```
清空元素
```cpp
a.clear();
```
删除任意元素 ${O\left( n \right)  }$ 
```cpp
v.erase(v.begin() + 2); // 删除v[2]
v.erase(v.begin + 1, v.begin() + 3); // 删除v[1],v[2]
```
任意位置插入元素 ${O\left( n \right)  }$ 
```cpp
vector<int> v{1,2,3};
v.insert(v.begin(), 4); // 4,1,2,3

vector<int> v{1,2,3};
v.insert(v.begin() + 1, {4,5,6}); // 1,4,5,6,2,3

vector<int> v1{1,2,3};
vector<int> v2{4,5,6};
v1.insert(v1.end(), v2.begin(), v2.end()); // 1,2,3,4,5,6
```
排序 ${O\left( n\log n \right)  }$ 
```cpp
// 默认从小到大排序
sort(a.begin(), a.end());
// 从大到小排序
sort(a.begin(), a.end(), greater<int>());
```

题目：
[力扣 1472. 设计浏览器历史记录](https://leetcode.cn/problems/design-browser-history/) 

## 哈希表 unordered_map
头文件：`#include<unordered_map>` 
定义
```cpp
unordered_map<key类型, val类型> h;
unordered_map<string, int> h;
```
添加键值对 ${O\left( 1 \right)  }$ 
```cpp
h["one"] = 1;
```
根据键找对应值 ${O\left( 1 \right)  }$ 
```cpp
// 如果对应键没有值，则会自动添加一个键值对，值为0
h[key]
```
查询是否存在键 ${O\left( 1 \right)  }$ 
```cpp
h.count(x);
```
清空
```cpp
h.clear();
```

题目：
[洛谷 P1765 手机](https://www.luogu.com.cn/problem/P1765) 
[力扣 350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/) 
[洛谷 P1603 斯诺登的密码](https://www.luogu.com.cn/problem/P1603) 
[洛谷 P3613 寄包柜](https://www.luogu.com.cn/problem/P3613) 
[力扣 49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/) 
[力扣 2506. 统计相似字符串对的数目](https://leetcode.cn/problems/count-pairs-of-similar-strings/) 
[力扣 1.两数之和](https://leetcode.cn/problems/two-sum/description/) 
[力扣 454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/) 
[acwing 1532. 找硬币](https://www.acwing.com/problem/content/1534/) 
[力扣 1282. 用户分组](https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/) 


## 有序哈希表 map
头文件：`#include<map>` 
元素按键升序排序
定义
```cpp
map<key类型, val类型> h;
map<string, int> h;
```
遍历
```cpp
for(map<key类型 ,val类型>::iterator it = h.begin(); it != h.end(); ++i){
	key = i->first;
	val = i->second;
}

for(auto &[key, val] : h){
	cout << key << " " << val;
}
```
map 支持 `lower_bound` 和 `upper_bound` 来二分查找
```cpp
auto it = h.lower_bound(x);
```
其他操作同 `unordered_map` ，插入和查找的时间复杂度为 ${O\left( \log n \right)  }$ 



## 集合 unordered_set
头文件：`#include<unordered_set>` 
集合在插入元素时会自动去重（需要元素支持 hash）
定义
```cpp
unordered_set<类型> st;
unordered_set<int> st;
```
插入元素 ${O\left( 1 \right)  }$ 
```cpp
st.insert(x);
```
删除元素 ${O\left( 1 \right)  }$ 
```cpp
st.erase(x);
```
查询元素是否在集合中 ${O\left( 1 \right)  }$ 
```cpp
st.count(x);
```
元素个数 ${O\left( 1 \right)  }$ 
```cpp
st.size();
```
查找元素的迭代器
```cpp
st.find(x);
找不到则返回st.end()
```
自定义哈希函数
```cpp
unordered_set<pair<int, int>, decltype([](pair<int, int> x){
	return(size_t) x.first ^ x. second;
})> s;

双重检查：
unordered_set<pair<int, int>, decltype([](pair<int, int> x){
	return(size_t) x.first ^ x.second;
}), decltype([](pair<int, int> a, pair<int, int> b){
	// 当两个元素的哈希值相等时的额外判断，重载相等
	return x.first == y.first;
})> s;

// 忽略浮点数误差:
unordered_set<double> us;
us.insert(0.1 + 0.2);
us.insert(0.3);
// 上面由于浮点数误差，导致没有去重

// 小数点后6位相同则认为相同
unordered_set<double, decltype([](double x){
	return(size_t)(x * 1e6);
}), decltype([](double a, double b){
	return fabs(a - b) < 1e-6;
})> s;
```

题目：
[洛谷 P3370. 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370) 
[力扣 349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/) 
[力扣 2956. 找到两个数组中的公共元素](https://leetcode.cn/problems/find-common-elements-between-two-arrays/) 
[力扣 36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/) 
[力扣 128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/) 
[力扣 2766. 重新放置石块](https://leetcode.cn/problems/relocate-marbles/) 

## 有序集合 set
头文件：`#include<set>` 
集合在插入元素时会自动去重（需要元素支持 <）
元素按键升序排序
定义
```cpp
set<类型> s;
set<int> s;
```
遍历
```cpp
for(set<类型>::iterator it = s.begin(); it != s.end(); ++i){
	a = *it;
}
```
set 支持 `lower_bound` 和 `upper_bound` 来二分查找
```cpp
auto it = s.lower_bound(x);
```
其他操作同 `unordered_set` ，插入和删除的时间复杂度为 ${O\left( \log n \right)  }$ 


## 二元对 pair
头文件：`#include<algorithm>` 
定义
```cpp
pair<元素1类型, 元素2类型> p;
pair<int, int> p;
```
元素访问
```cpp
// 第一个元素
p.first;
// 第二个元素
p.second;
```
与 `vector` 组合使用
```cpp
// 定义一个元素为pair的数组
vector<pair<int, int>> a;
// 为数组添加元素
a.push_back({1, 2});
// pair 可以使用 >, <, == 按字典序进行比较，也可以进行排序
sort(a.begin(), a.end()); // 先按照第一个元素进行排序再按第二个元素进行排序
```
与 `unordered_set`, `unordered_map` 组合使用
```cpp
// 实现pair的哈希函数
struct pair_hash{
	size_t operator()(const pair<int, int>& p) const{
		return p.first ^ p.second;
		// 或者
		// return hash<int>()(p.first) ^ hash<int>()(p.second);
	}
};

unordered_set<pair<int, int>, pair_hash> st;
unordered_map<pair<int, int>, pair_hash> h;
```


## 栈 stack
头文件：`#include<stack>` 
定义
```cpp
stack<类型> s;
stack<int> s;
```
入栈 ${O\left( 1 \right)  }$ 
```cpp
s.push(x);
```
出栈 ${O\left( 1 \right)  }$ 
```cpp
s.pop();
```
判断栈是否为空 ${O\left( 1 \right)  }$ 
```cpp
s.empty();
```
访问栈顶元素 ${O\left( 1 \right)  }$ 
```cpp
s.top();
```

题目：
[洛谷 P1427 小鱼的数字游戏](https://www.luogu.com.cn/problem/P1427) 
[洛谷 P1739. 表达式括号匹配](https://www.luogu.com.cn/problem/P1739) 
[力扣 2696. 删除子串后的字符串最小长度](https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/) 
[洛谷 P1449. 后缀表达式](https://www.luogu.com.cn/problem/P1449) 
[洛谷 P1165. 日志分析](https://www.luogu.com.cn/problem/P1165) 
[力扣 155. 最小栈](https://leetcode.cn/problems/min-stack/) 
[力扣 227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/) 
[acwing 3302. 表达式求值](https://www.acwing.com/problem/content/3305/) 
```cpp
stack<int> num;// 维护两个栈，一个存放数字，一个存放操作符
stack<char> op;
unordered_map<char, int> m = { {'+',1},{'-',1},{'*',2},{'/',2} };//操作及优先级

void eval() { // 计算栈顶两个数字和一个操作符的值
    int b = num.top(); num.pop();
    int a = num.top(); num.pop();
    char c = op.top(); op.pop();
    int x = 0;
    if (c == '+')x = a + b;
    else if (c == '-')x = a - b;
    else if (c == '*')x = a * b;
    else x = a / b;
    num.push(x);
}

int main() {
    string s;
    cin >> s;
    for (int i = 0; i < s.length(); i++) {
        if ('0' <= s[i] && s[i] <= '9') {//数字
            int x = 0;
            while (i < s.length() && '0' <= s[i] && s[i] <= '9') {
                x = x * 10 + s[i] - '0';
                i++;
            }
            i--;
            num.push(x);
        }
        else if (s[i] == '(') {
            op.push(s[i]);
        }
        else if (s[i] == ')') {
            while (op.top() != '(')eval();
            op.pop();
        }
        else {//运算符
            while (op.size() && m[op.top()] >= m[s[i]])eval();//将栈中所有优先级比当前高的计算完
            op.push(s[i]);
        }
    }
    while (op.size())eval();
    cout << num.top();
    return 0;
}
```
[力扣 331. 验证二叉树的前序序列化](https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/) 
[力扣 2390. 从字符串中移除星号](https://leetcode.cn/problems/removing-stars-from-a-string/) 
[力扣 3174. 清除数字](https://leetcode.cn/problems/clear-digits/) 

## 队列 queue
头文件：`#include<queue>`
定义
```cpp
queue<类型> q;
queue<int> q;
```
队尾增加元素 ${O\left( 1 \right)  }$ 
```cpp
q.push(x);
```
队头出队 ${O\left( 1 \right)  }$ 
```cpp
q.pop();
```
访问队首元素 ${O\left( 1 \right)  }$ 
```cpp
q.front();
```
判断队列是否为空 ${O\left( 1 \right)  }$ 
```cpp
q.empty();
```

题目：
[洛谷 P1540. 机器翻译]( https://www.luogu.com.cn/problem/P1540 ) 

## 双端队列 deque
头文件：`#include<deque>` 
定义
```cpp
deque<类型> q;
```
队头/队尾加入元素 ${O\left( 1 \right)  }$ 
```cpp
// 队头加入元素
q.push_front(x);
// 队尾加入元素
q.push_back(x);
```
队头/队尾弹出元素 ${O\left( 1 \right)  }$ 
```cpp
// 队头弹出元素
q.pop_front();
// 队尾弹出元素
q.pop_back();
```
访问队头/队尾 ${O\left( 1 \right)  }$ 
```cpp
// 访问队头
q.front();
// 访问队尾
q.back();
```
`deque` 支持下标访问
```cpp
q[0];  // 第一个元素
```

题目：
[洛谷 P1996. 约瑟夫问题](https://www.luogu.com.cn/problem/P1996) 
[洛谷 P2021 faebdc玩扑克](https://www.luogu.com.cn/problem/P2021) 


## 堆（优先队列）priority_queue
头文件：`#include<queue>` 
默认为大根堆，即出队时按照从大到小的顺序出队
定义
```cpp
// 默认从大到小出队
priority_queue <数据类型> heap;
// 定义从小到大出队
priority_queue <int, vector<int>, greater<int> > heap;
// 小技巧：可以取负入队，然后出队后再取负。也可以完成从小到大出队
```
加入元素 ${O\left( \log n \right)  }$ 
```cpp
heap.push(x);
```
出队 ${O\left( \log n \right)  }$ 
```cpp
// 按照权值出队
heap.pop();
```
查询堆顶 ${O\left( 1 \right)  }$ 
```cpp
heap.top();
```

自定义堆排序
```cpp
案例一：队列中的元素是一个有两个元素的数组，如{1, 2}，堆要按照第二个元素排序
struct cmp{
	bool operator()(const auto &e1, const auto &e1) const{
		return e1.second > e2.second; // 小根堆
	}
}
priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> q;
q.push({1, 2});

案例二：队列中的元素是一个有三个元素的数组，如{1, 2, 3}，堆要按照第三个元素排序
struct cmp{
	bool operator()(const auto &e1, const auto &e2) const{
		return e1[2] > e2[2]; // 小根堆
	}
}
priority_queue<vector<int>, vector<vector<int>>, cmp> q;
q.push({1, 2, 3});

使用匿名函数重载小于号
priority_queue<int, vector<int>, decltype([](int a, int b){
	return a > b;
})> q;
```

题目： 
[acwing 148. 合并果子](https://www.acwing.com/activity/content/problem/content/1115/) 
[力扣 2530. 执行 K 次操作后的最大分数](https://leetcode.cn/problems/maximal-score-after-applying-k-operations/) 
[力扣 2558. 从数量最多的堆取走礼物](https://leetcode.cn/problems/take-gifts-from-the-richest-pile/) 
[力扣 2208. 将数组和减半的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/) 
[力扣 2617. 网格图中最少访问的格子数](https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/) 


## 双向链表 list
头文件：`#include<list>` 
定义/初始化
```cpp
list<类型> ls;
// 从数组初始化
int arr[5]={1, 2, 3};
list<int> ls(arr, arr + 3) // 从数组arr中的前三个元素作为链表ls的初始值
```
链表长度
```cpp
ls.size();
```
获取迭代器
```cpp
list<类型>::iterator it = ls.begin(); // 尾迭代器：ls.end()
```
表头/表尾添加元素
```cpp
// 表头添加元素
ls.push_front(x);
// 表尾添加元素
ls.push_back(x);
```
在任意位置插入元素
```cpp
// 在it迭代器前插入元素x
ls.insert(it, x);
```
删除表头/表尾元素
```cpp
// 删除表头元素
ls.pop_front();
// 删除表尾元素
ls.pop_back();
```
删除任意位置的元素
```cpp
// 删除迭代器it所在元素，注意删除后it也会失效
ls.erase(it);
```
遍历链表
```cpp
for(list<类型>::iterator it = ls.begin(); it != ls.end(); ++it){
	x = *it;
}
```

题目：
[力扣 2296. 设计一个文本编辑器](https://leetcode.cn/problems/design-a-text-editor/) （双向链表/栈）
# STL 函数
## 快速选择 nth_element
将第 ${k }$ 小的数移动到第 ${k }$ 位
```cpp
nth_element(a.begin(), a.bgin() + k, e.end())
```


## 二分查找 lower_bound, upper_bound
在有序数组中，找到第一个 ${\geq  v}$ 的迭代器
`lower_bound(Iterator begin, Iterator end, Type v, Function, comp)` 
在有序数组中，找到第一个 ${>v }$ 的迭代器
`upper_bound(Iterator begin, Iterator end, Type v, Function, comp)` 
```cpp
找2：
1 1 2 2 2 2 3 3
    l       u

找2：
1 1 3 3 3 3 4 4
    [l,u]
```


## 求排列 next_permutation, prev_permutation
生成下一个排列，在原数组中直接修改（去重）
如果已经是最后一个排列，则修改为最小排列，返回 false
`bool next_permutation(Iterator begin, Itearator end)` 

```cpp
vector<int> a = {1, 1, 1, 3};
do{
	for(auto &x : a) cout << x << " ";
	cout << endl;
}while(next_permutation(a.begin(), a.end()));
```

## 去重 unique
`unique(Iterator begin, Iterator end, Function matcher)` 
时间复杂度 ${O\left( n \right)  }$ 
移除相邻的相同元素，并返回新序列的尾迭代器。（实际上是将多余元素移动到了后面）
可以自定义【相同】

```cpp
vector<int> vec = {1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1};
vec.erase(unique(vec.begin(), vec.end()), vec.end()); // {1, 2, 1}
```

## 数组求最值 min_element, max_element
`min_element(Iterator begin, Iterator end, Funtion comp)` 
时间复杂度 ${O\left( n \right)  }$ 
最后最小值的迭代器，可以自定义比较函数


## 数组求和 accumulate
`#include<numeric>`
`Type accumulate(Iterator begin, Iterator end, Type init, Function Operator)` 
时间复杂度 ${O\left( n \right)  }$ 
对范围内的数值进行累加
可以修改累加操作

```cpp
long long sum = accumulate(a.begin(), a.end(), 0ll); // 注意累加可能爆int，要传入0ll
```


## 数组填充 fill
`#include<algorithm>` 
`fill(起点，终点，值)` 
```cpp
fill(arr, arr + n, 10);
```


## 字节填充 memset
`#include<cstring>` 
`memset(起始地址, 字节值, 字节数量)` 
注意赋值是以字节为单位
```cpp
memset(arr, 0x3f, sizeof arr);
```

## 内存拷贝 memcpy
`#include<cstring>` 
`memcpy(目标起始地址, 源起始地址, 字节数量)` 
```cpp
memcpy(arr2, arr1, sizeof arr1);
```

## C 字符串类型转换 atoi, atoll, atof
`#include<stdlib.h>` 
将 c 语言的字符串转成对应类的数值, 'a'的含义是 ascii
```cpp
atoi("123"); // 123
atoll("12345678901"); // 12345678901
atof("3.14"); // 3.14
atof("1e-4"); // 0.0001
atof("0x1p-2"); // 0.25

如果字符串不合法，结果为0
atof("abc"); // 0
```


## 条件查找 find_if
查找范围内第一个满足条件的元素
`Iterator find_if(Iterator first, Iterator last, Function matcher)` 
```cpp
// 找到第一个>target的元素
vector<int> a = {5, 8, 4, 3, 2, 100, 7, 1, 6};
int target = 10;
int index = find_if(a.begin(), a.end(), [target](int x){
	return x > target;
}) - a.begin();
```

## 遍历 for_each
`#include <algorithm>` 
遍历每个元素，对每个元素执行相同的操作
```cpp
// 输出小于目标值的元素
std::for_each(v.begin(), v.end(), [target](int x) {
	if (x < target) { std::cout << x << " "; }
});
```




# 手写数据结构
## 链表：

### 单链表

```cpp
const int N = 100010;//此为静态链表，确保长度足够
struct List
{
    int val[N] = { 0 };//存值
    int next[N] = { 0 };//当前下标的下一个下标
    int head = 0, idx = 0;//头结点的下标,当前节点的下标
    void add(int x)//头插法
    {
        val[++idx] = x;
        next[idx] = next[head];
        next[head] = idx;
    }
    void insert(int x, int k)//将x插入下标是k的点的后面
    {
        val[++idx] = x;
        next[idx] = next[k];
        next[k] = idx;
    }
    void del(int k)//将下标是k的点的下一个点删除
    { next[k] = next[next[k]]; }
};
从头遍历:
for (int i = l.ne[l.head]; i != 0; i = l.ne[i])
    cout << l.e[i] << " ";
```

### 双链表

```cpp
const int N = 100010;//此为静态链表，确保长度足够
struct List
{
    int l[N] = { 0 };//当前下标的前面的下标
    int r[N] = { 0 };//当前下标的后面的下标
    int e[N] = { 0 };//当前下标存储的值
    int head = 0, tail = -1, idx = 0;//头下标，尾下标，当前下标
    lst(){//初始化
        r[head] = tail;
        l[tail] = head;
    }
    void insert(int x, int k){//将x插入下标是k的点的后面
        e[++idx] = x;
        l[idx] = k;
        r[idx] = r[k];
        l[r[k]] = idx;
        r[k] = idx;
    }
    void del(int k){//将下标是k的点删除
        r[l[k]] = r[k];
        l[r[k]] = l[k];
    }
};
从头遍历:
for (int i = dl.r[dl.head]; i != dl.tail; i = dl.r[i])
    cout << dl.e[i] << " ";
```


## 栈：

```cpp
//防卡常
const int N = 100010;
struct Stack
{
	int val[N];
	int idx = 0;//元素个数
	void push(int x) { val[++idx] = x; }//入栈
	void pop() { if (idx)idx--; }//出栈
	int size() { return idx; }//栈元素个数
	int top() { return val[idx]; }//询问栈顶元素
	bool empty() { return idx == 0; } //判读栈是否为空;
    void clear() { idx = 0; }//栈清空
};
```


## 队列：
**循环双端队列** 
如果不要双端，去掉 8，9 行的函数即可.
请确保所有操作合法，不要越界！否则会出问题！

```cpp
const int N = 100010;//请确保够用
struct Queue
{
	int val[N];
	int  h = 0, t = 0;//h所指向的单元不存放数据
	void push_back(int x) { val[++t %= N] = x; }//队尾入队
	void pop_front() { ++h %= N; }//队头出队
    //void push_front(int x) { val[h--] = x; h = (h + N) % N; }//队头出队
	//void pop_back() { t = (--t + N) % N; }//队尾出队
	int front() { return val[h + 1]; }//队首元素
	int back() { return val[t]; }//队尾元素
	int size() { return (t - h + N) % N; }//元素个数
	bool empty() { return h == t; }//队列是否为空
    void clear() { h = 0; t = 0; }//队列清空
};
```

## 堆
下沉：$O(\log n)$ ，上浮：$O(\log n)$ 
建堆：$O(n)$ ，从 $n/2$ 到 $1$ 都 down 一遍
插入：$O(\log n)$ ，删除：$O(\log n)$ 
求最小值 $O(1)$ 
堆排序：${O\left( n\log n \right)  }$ ，不断删除堆顶元素
该模板为小根堆，若需要大根堆，修改 ${6,7,14 }$ 行的 ${< }$ 为 ${> }$ 

```cpp
struct heap
{
    int h[N], idx = 0;
    void down(int k){//下沉
        int t = k;
        if (2 * k <= idx && h[2 * k] > h[t])t = 2 * k; // 大根堆用>，小根堆用<
        if (2 * k + 1 <= idx && h[2 * k + 1] > h[t])t = 2 * k + 1; // 大根堆用>，小根堆用<
        if (t != k){
            swap(h[k], h[t]);
            down(t);
        }
    }
    void up(int k){//上浮
        if (k > 1 && h[k] > h[k / 2]){ // 大根堆用>，小根堆用<
            swap(h[k], h[k / 2]);
            up(k / 2);
        }
    }
    void add(int x) { h[++idx] = x; }//加入数组
    void build() { for (int i = idx / 2; i >= 1; i--) down(i); }//建堆
    void push(int x) { h[++idx] = x; up(idx); }//插入一个数
    void pop() { swap(h[1], h[idx--]); down(1); }//删除最小值
    void del(int k) { swap(h[k], h[idx--]); down(k); up(k); }//删除位置为k的元素
    void change(int k, int x) { h[k] = x; down(k); up(k); }//修改位置k的元素为x
    int top() { return h[1]; }//最小值
    int size() { return idx; }//元素数量
    void sort(){ while(idx){ del(1); } } // 堆排序，大根堆递增，小根堆递减
};
```


## 哈希表
### 开放寻址法

```cpp
const int N = 200003, null = 0x3f3f3f3f;
struct hashtable
{
	int h[N];
	hashtable() { memset(h, 0x3f, sizeof(h)); }
	void insert(int x)//插入
	{
		int t = (x % N + N) % N;
		while (h[t] != null)++t %= N;
		h[t] = x;
	}
	bool query(int x)//查找
	{
		int t = (x % N + N) % N;
		while (h[t] != null && h[t] != x)++t %= N;
		return h[t] == x;
	}
};
```

### 拉链法

```cpp
const int N = 100003;
struct hashtable
{
    int h[N];
    int e[N], ne[N], idx = 0;
    hashtable() { memset(h, -1, sizeof(h)); }
    void insert(int x)//插入
    {
        int t = (x % N + N) % N;
        e[++idx] = x;
        ne[idx] = h[t];
        h[t] = idx;
    }
    bool query(int x)//查找
    {
        int t = (x % N + N) % N;
        for (int i = h[t]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;
        return false;
    }
};
```



# 简单算法
## 枚举
[acwing 1353. 滑雪场设计](https://www.acwing.com/problem/content/description/1355/) 
[力扣 2917. 找出数组中的 K-or 值](https://leetcode.cn/problems/find-the-k-or-of-an-array/) 
[力扣 3047. 求交集区域内的最大正方形面积](https://leetcode.cn/problems/find-the-largest-area-of-square-inside-two-rectangles/) 
[acwing 3227. 折点计数](https://www.acwing.com/problem/content/3230/) 
[acwing 5818. 保险箱窃贼](https://www.acwing.com/problem/content/5821/) 
[acwing 458. 比例简化](https://www.acwing.com/problem/content/description/460/) 

## 模拟
[洛谷 P1046. 陶陶摘苹果](https://www.luogu.com.cn/problem/P1046) 
[acwing 421. 陶陶摘苹果](https://www.acwing.com/problem/content/423/) 
[acwing 417. 不高兴的津津](https://www.acwing.com/problem/content/419/) 
[acwing 1341. 十三号星期五](https://www.acwing.com/problem/content/description/1343/) 
[acwing 703. 数独检查](https://www.acwing.com/problem/content/705/) 
[洛谷 P1055. ISBN 号码](https://www.luogu.com.cn/problem/P1055) 
[acwing 433. ISBN 号码](https://www.acwing.com/problem/content/description/435/) 
[acwing 3232. 最大波动](https://www.acwing.com/problem/content/3235/) 
[acwing 3257. 跳一跳](https://www.acwing.com/problem/content/3260/) 
[力扣 67. 二进制求和](https://leetcode.cn/problems/add-binary/) 
[力扣 8. 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/) 

## 数位拆分
```cpp
while(x){
	r = x % 10; // 提取个位数
	x /= 10;
}
```
[洛谷 P1980 计数问题](https://www.luogu.com.cn/problem/P1980) 
[洛谷 P1307 数字反转]( https://www.luogu.com.cn/problem/P1307 ) 
[acwing 445. 数字反转](https://www.acwing.com/problem/content/447/) 
[力扣 7. 整数反转](https://leetcode.cn/problems/reverse-integer/) 
[洛谷 P1554 梦中的统计](https://www.luogu.com.cn/problem/P1554) 
[力扣 3099. 哈沙德数](https://leetcode.cn/problems/harshad-number/) 
[acwing 441. 数字统计](https://www.acwing.com/problem/content/443/) 
[acwing 1477. 拼写正确](https://www.acwing.com/problem/content/1479/) （哈希表 + 数位拆分）
[力扣 202. 快乐数](https://leetcode.cn/problems/happy-number/) （哈希表 + 数位拆分）
[力扣 9. 回文数](https://leetcode.cn/problems/palindrome-number/) 
[力扣 1742. 盒子中小球的最大数量](https://leetcode.cn/problems/maximum-number-of-balls-in-a-box/) 

## 数组构造
[acwing 756. 蛇形矩阵](https://www.acwing.com/problem/content/758/) 
[洛谷 P5731 蛇形方阵](https://www.luogu.com.cn/problem/P5731) 
[力扣 54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/) 
[力扣 LCR 146. 螺旋遍历二维数组](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/) 
[力扣 59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/) 
[力扣 6. Z 字形变换](https://leetcode.cn/problems/zigzag-conversion/description/) 
[acwing 754. 平方矩阵 II](https://www.acwing.com/problem/content/756/) 
[洛谷 P2615 神奇的幻方]( https://www.luogu.com.cn/problem/P2615 ) 
[洛谷 P1205 方块转换](https://www.luogu.com.cn/problem/P1205) 
[acwing 3208. Z字形扫描](https://www.acwing.com/problem/content/3211/) 

## 数组分段
将一个数组分成若干连续段，每一段具有相同性质
```cpp
初始化组
for 每一个元素item{
	if(将item加入组内满足条件){
		将item加入组
		维护组内性质
	}
	else{
		记录上一个组
		初始化组
		将item加入组
	}
}
记录上一个组
```

[力扣 3011. 判断一个数组是否可以变为有序](https://leetcode.cn/problems/find-if-array-can-be-sorted/) 
[力扣 3101. 交替子数组计数](https://leetcode.cn/problems/count-alternating-subarrays/) 
[洛谷 P1181 数列分段 Section I](https://www.luogu.com.cn/problem/P1181) 
[力扣 2414. 最长的字母序连续子字符串的长度](https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/) 
[力扣 228. 汇总区间](https://leetcode.cn/problems/summary-ranges/) 

## 递归
[洛谷 P1010 幂次方]( https://www.luogu.com.cn/problem/P1010 ) 
[力扣 394. 字符串解码](https://leetcode.cn/problems/decode-string/) 
[力扣 726. 原子的数量](https://leetcode.cn/problems/number-of-atoms/) 
[洛谷 P5461 赦免战俘](https://www.luogu.com.cn/problem/P5461) 

### 主定理（master 公式）
用来确定递归算法的时间复杂度
对于问题规模为 ${n }$ 时，递归中某一层 ${T\left( n \right) =a\times T\left( \frac{n}{b}  \right) +O\left( n^{c}  \right)  }$ 其中 ${a,b,c }$ 为常数
1. 如果 ${\log _{b} ^{a} <c }$，则复杂度为 ${O\left( n^{c}  \right)  }$ 
2. 如果 ${\log _{b} ^{a} >c }$，则复杂度为 ${O\left( n^{\log _{b} ^{a}  }  \right)  }$ 
3. 如果 ${\log _{b} ^{a} =c }$，则复杂度为 ${O\left( n^{c} \log n \right)  }$ 
另外，如果 ${T\left( n \right) =2\times T\left( \frac{n}{2}  \right) +O\left( n\log n \right)  }$，则复杂度为 ${O\left( n\log^{2}  n \right)  }$ （常用但非主定理内容）


# 基础算法
## 排序
### 快速排序
#### STL 快速排序
- 时间复杂度：${O\left( n\log n \right)  }$ 

头文件： `#include<algorithm>` 
使用：
```cpp
sort(起始地址，结束地址，[排序方式函数]);//默认从小到大排序
// sort(a.begin(), a.end(), cmp);
```
自定义结构体比较函数：
```cpp
bool cmp(结构体名 a, 结构体名 b){
    if(a.first != b.first)return a.first > b.first;
    if(a.second != b.second)return a.second > b.second;
    ...
    return a.final > b.final;
}
```
去重：（去重之前要先排序！）
```cpp
// 该函数返回值为去重后最后一个地址，多余的数全部会放在末尾
unique(起始地址，结束地址);

去重后元素数量：x = unique(a, a + n) - a
```

题目：
[acwing 425. 明明的随机数](https://www.acwing.com/problem/content/427/) 
[洛谷 P1093. 奖学金]( https://www.luogu.com.cn/problem/P1093 ) 
[acwing 429. 奖学金](https://www.acwing.com/problem/content/431/) 
[洛谷 P1781. 宇宙总统](https://www.luogu.com.cn/problem/P1781) 
[洛谷 P5740. 最厉害的学生](https://www.luogu.com.cn/problem/P5740) 
[洛谷 P1104. 生日](https://www.luogu.com.cn/problem/P1104) 
[洛谷 P5143. 攀爬者](https://www.luogu.com.cn/problem/P5143) 
[洛谷 P5741. 旗鼓相当的对手 - 加强版](https://www.luogu.com.cn/problem/P5741) 
[洛谷 P1068. 分数线划定]( https://www.luogu.com.cn/problem/P1068 ) 

#### 手写快速排序
将数组 `a` 在区间 `[l,r]` 进行从小到大排序 (从大到小请改第 6, 7行的符号)
- 时间复杂度：${O\left( n\log n \right)  }$ 
```cpp
void qsort(int a[], int l, int r){
    if (l == r) return;
    // 中间的数作为哨兵, i和j分别指向左右两端的外侧
    int flag = a[l + r >> 1], i = l - 1, j = r + 1;
    while (i < j){
        while (a[++i] < flag); // 找到左侧第一个大于等于flag的数
        while (a[--j] > flag); // 找到右侧第一个小于等于flag的数
        if (i < j) swap(a[i], a[j]);
    }
    qsort(a, l, j); // 递归左侧
    qsort(a, j + 1, r); // 递归右侧
}
```

题目：
[acwing 758. 快速排序](https://www.acwing.com/problem/content/787/) 
[洛谷 P1177.  排序](https://www.luogu.com.cn/problem/P1177) 
[力扣 912. 排序数组](https://leetcode.cn/problems/sort-an-array/) 

### 归并排序
将数组 `a` 在区间 `[l,r]` 进行从小到大排序 (从大到小请改第 11 行的符号)
- 时间复杂度：${O\left( n\log n \right)  }$ 
- 空间复杂度：${O\left( n \right)  }$ 
```cpp
int tmp[N];//需要额外的临时空间
void merge_sort(int a[], int l, int r){
    if (l == r) return;
    int mid = l + r >> 1;
    merge_sort(a, l, mid); // 递归排序左半部分
    merge_sort(a, mid + 1, r); // 递归排序右半部分
    // i指向左半部分的第一个数，j指向右半部分的第一个数，k指向临时数组的第一个数
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r){
        // 将较小的数放入临时数组
        if (a[i] <= a[j]) tmp[k++] = a[i++];
        else tmp[k++] = a[j++];
    }
    while (i <= mid) tmp[k++] = a[i++]; // 将左半部分剩余的数放入临时数组
    while (j <= r) tmp[k++] = a[j++]; // 将右半部分剩余的数放入临时数组
    for (int i = l, j = 0; i <= r; i++, j++) // 将临时数组的数放回原数组
        a[i] = tmp[j];
}
```

题目：
[acwing 787. 归并排序](https://www.acwing.com/problem/content/789/) 

### 基数排序
要求元素都为非负整数

- 时间复杂度：${O\left( n \right)  }$ 
- 空间复杂度：${O\left( n+BASE \right)  }$ 
```cpp
const int BASE = 10;
int t[N], cnts[BASE]; // 两个辅助数组

void radix_sort(int a[], int l, int r, int bits){ // bits表示BASE进制下最大的数的位数
    int k = 1;
    while(bits--){
        memset(cnts, 0, sizeof cnts);
        for(int i = l; i <= r; i++){
            cnts[(a[i] / k) % BASE]++;
        }
        for(int i = 1; i < BASE; i++){ // 升序排序
            cnts[i] += cnts[i - 1];
        }
        // for(int i = BASE - 2; i >= 0; i--){ // 降序排序
        //     cnts[i] += cnts[i + 1];
        // }
        for(int i = r; i >= l; i--){
            t[--cnts[(a[i] / k) % BASE] + l] = a[i];
        }
        for(int i = l; i <= r; i++){
            a[i] = t[i];
        }
        k *= BASE;
    }
}
```

## 快速选择算法
得到一个序列中从小到大排列后的第 ${k }$ 个数
### 手写快速选择算法
说明：快速选择算法是基于快速排序的变形，核心思想是利用快速排序分区间进行排序，且只对可能包含答案的那一半区间进行排序，剩下的区间可以不做处理
模板 1
- 时间复杂度：${O\left( n \right)  }$ 
- 空间复杂度：${O\left( \log n \right)  }$ 
- 该模板的 `k` 从 `1` 开始
```cpp
// 模板1
int qselect(int a[], int l, int r, int k){
    if (l == r) return a[l];
    // 中间的数作为哨兵, i和j分别指向左右两端的外侧
    int x = a[l + r >> 1], i = l - 1, j = r + 1;
    while (i < j){
        while (a[++i] < x); // 找到左边第一个大于等于x的数
        while (a[--j] > x); // 找到右边第一个小于等于x的数
        if (i < j) swap(a[i], a[j]);
    }
    int lcnt = j - l + 1; //左边数的个数
    if (lcnt >= k) return qselect(a, l, j, k); // 如果左边数的个数大于等于k，那么第k大的数一定在左边
    else return qselect(a, j + 1, r, k - lcnt); // 否则第k大的数在右边
}
```

模板 2
- 时间复杂度：${O\left( n \right)  }$ 
- 空间复杂度：${O\left( 1 \right)  }$ 
- 该模板的 `k` 从 `1` 开始
```cpp
// 模板2
int qselect(int a[], int l, int r, int k){
	while(true){
	    if (l == r) return a[l];
	    // 中间的数作为哨兵, i和j分别指向左右两端的外侧
	    int x = a[l + r >> 1], i = l - 1, j = r + 1;
	    while (i < j){
	        while (a[++i] < x); // 找到左边第一个大于等于x的数
	        while (a[--j] > x); // 找到右边第一个小于等于x的数
	        if (i < j) swap(a[i], a[j]);
	    }
	    int lcnt = j - l + 1; //左边数的个数
		if (lcnt >= k) r = j;
		else{
			l = j + 1;
			k -= lcnt;
		}
	}
}
```


题目：
[acwing 786.第k个数](https://www.acwing.com/problem/content/788/) 
[洛谷 P1923. 求第 k 小的数](https://www.luogu.com.cn/problem/P1923) 
[力扣 215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/) 
[力扣 2583. 二叉树中的第 K 大层和](https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree/description/) （搜索+快速选择）
[acwing 2041. 干草堆](https://www.acwing.com/problem/content/description/2043/) （差分 + 快速选择）

### STL 快速选择算法
`nth_element` 的作用就是根据 `nth` 这个位置，把容器内的元素分为 2 组，`nth` 之前的都比它小，`nth` 之后的都比它大。
头文件： `#include<algorithm>` 
- 时间复杂度：${O\left( n \right)  }$ 
```cpp
nth_element(头指针, 分割位置的指针, 尾指针, [排序方式]) // 排序方式默认从小到大

nth_element(a.begin(), a.begin() + k - 1, a.end()); // 根据第k小的数进行划分
cout << a[k - 1]; // 第k小的数


bool cmp(int a, int b){
    return a > b;
}
nth_element(a.begin(), a.begin() + k - 1, a.end(), cmp); // 根据第k大的数进行划分
cout << a[k - 1]; // 第k大的数
```



## 归并分治
归并分治是由归并排序衍生出来的一种算法，当问题满足以下几个性质时可以使用归并分治来求解
- 一个问题在大区间上的答案 = 左区间的答案 + 右区间的答案 + 跨越左右产生的答案
- 左右区间各自有序的情况下，求解跨越左右产生的答案可以被优化成线性

[力扣 493. 翻转对](https://leetcode.cn/problems/reverse-pairs/) 
### 求逆序对数量
求序列中逆序对的数量（逆序对定义：对于数列的第 ${i }$ 个和第 ${j }$ 个元素，如果满足 ${i<j }$ 且 ${a\left[ i \right] >a\left[ j \right]  }$，则其为一个逆序对）
对于 ${n }$ 个元素的序列，逆序对数量最多为 ${n^{2}  }$ 级别，要防止爆 `int` 
- 时间复杂度：${O\left( n\log n \right)  }$ 
```cpp
// 求解区间[l,r]的逆序对，同时对该区间排序
LL mergesort(int a[], int l, int r){
    if(l == r) return 0;
    int mid = l + r >> 1;
    LL cnt = mergesort(a, l, mid) + mergesort(a, mid + 1, r); // 递归求解左右两部分的逆序对数量
    
    // 统计跨左右答案
    for(int i = l, j = mid + 1; i <= mid; i++){
        while(j <= r && a[i] > a[j]) j++;
        cnt += j - mid - 1;
    }
    
    // 归并排序部分
    // i指向左半部分的第一个数，j指向右半部分的第一个数, k指向临时数组的第一个数
    int i = l, j = mid + 1, k = 0;
    while(i <= mid && j <= r){
        if(a[i] <= a[j]) tmp[k++] = a[i++];
        else tmp[k++] = a[j++];
    }
    while(i <= mid) tmp[k++] = a[i++]; // 将左半部分剩余的数放入临时数组
    while(j <= r) tmp[k++] = a[j++]; // 将右半部分剩余的数放入临时数组
    for(int i = l, j = 0; i <= r; i++, j++) // 将临时数组的数放回原数组
        a[i] = tmp[j];
    return cnt;
}
```

题目：
[acwing 788. 逆序对的数量](https://www.acwing.com/problem/content/790/) 
[力扣 LCR 170. 交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) 
[洛谷 P1908 逆序对](https://www.luogu.com.cn/problem/P1908) 
[洛谷 P1116 车厢重组](https://www.luogu.com.cn/problem/P1116) 
[acwing 5817. 交换车厢](https://www.acwing.com/problem/content/5820/) 
[acwing 107. 超快速排序](https://www.acwing.com/problem/content/description/109/) 

## 二分
### 浮点数二分
在 ${\left[ l,r \right]  }$ 中找到唯一解，要求解函数在数轴上是单调的
说明： `eps` 是精度，题目要求保留 ${k }$ 位数字，则 `eps` 一般是 `1e-(k+2)` 
- 时间复杂度：${O\left( \log \frac{r-l}{eps}  \right)  }$ 
```cpp
const int double eps = 1e-4;//精度
while (r - l > eps){
    double mid = (l + r) / 2;
    if (check(mid))r = mid; // check()：mid在解的右边返回true
    else l = mid;
}
```

题目：
[acwing 790. 数的三次方根](https://www.acwing.com/problem/content/792/) 
[洛谷 P1024. 一元三次方程求解](https://www.luogu.com.cn/problem/P1024) 


### 整数二分
在有序序列中找到第一个/最后一个满足某条件的位置
- 时间复杂度：${O\left( \log n \right)  }$ 

模板 1：找到第一个满足条件的位置
```cpp
// 找到第一个满足条件的位置
while (l < r){
    int mid = l + r >> 1;
    if (check(mid)) r = mid; // check()：mid位置满足查找条件返回true
    else l = mid + 1;
}//l或r是答案
```

模板 2：找到最后一个满足条件的位置
```cpp
// 找到最后一个满足条件的位置
while (l < r){
    int mid = l + r + 1 >> 1; // 注意要 +1，不然会死循环
    if (check(mid)) l = mid; // check()：mid位置满足查找条件返回true
    else r = mid - 1;
}//l或r是答案
```

题目：
[acwing 789. 数的范围](https://www.acwing.com/problem/content/791/) 
[力扣 34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/) 
[力扣 704. 二分查找](https://leetcode.cn/problems/binary-search/) 
[洛谷 P2249. 查找](https://www.luogu.com.cn/problem/P2249) 
[力扣 35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/) 
[力扣 69. x 的平方根](https://leetcode.cn/problems/sqrtx/) 
[力扣 367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/) 
[洛谷 P1102. A-B 数对](https://www.luogu.com.cn/problem/P1102) 
[洛谷 P1678. 烦恼的高考志愿](https://www.luogu.com.cn/problem/P1678) 
[力扣 2476. 二叉搜索树最近节点查询](https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/) （树的搜索 + 二分）
[力扣 475. 供暖器](https://leetcode.cn/problems/heaters/) 
[力扣 153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/) 
[力扣 154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/) 
[力扣 33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/) 
[力扣 81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/) 
[力扣 2080. 区间内查询数字的频率](https://leetcode.cn/problems/range-frequency-queries/) （哈希表 + 二分）

### STL 二分
- 头文件 `#include<algorithm>` 
使用：
`lower_bound` 
```cpp
在数组arr中查找第一个 >= val的位置
如果所有元素都小于val，则返回尾指针
lower_bound(arr[], arr[]+size, val);
```
`upper_bound` 
```cpp
在数组arr中查找第一个 > val的位置
如果所有元素都小于等于val，则返回尾指针
lower_bound(arr[], arr[]+size, val);
```


### 二分答案
一种二分的应用题型。原理是对答案进行二分搜索。
二分答案的题目具有以下特征：
1. 求最大值/最小值
2. 题干中有一个限制量（可能很隐蔽）
3. 答案与限制量之间存在单调关系
此外出现以下字眼的题目可能是二分答案：
- 最小的最大/最大的最小 
时间复杂度：${O\left( \text{check}\left( x \right) \cdot \log \left( r-l \right) \right)  }$ , ${l,r }$ 为答案可能取值的边界，${\text{check} \left( x \right)  }$ 为判定某个答案 ${x }$ 是否满足条件的函数

分析步骤：
1. 把答案作为自变量，把题目中有限制的那个量作为因变量
2. 分析函数的单调性
3. 确定限制条件
4. 确定要找的答案位置（最好画图）
5. 确定模板

题目：
[洛谷 P1182. 数列分段 Section II](https://www.luogu.com.cn/problem/P1182) 
[力扣 410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/) 
[acwing 1227.分巧克力](https://www.acwing.com/problem/content/1229/) 
[acwing 680. 剪绳子](https://www.acwing.com/problem/content/682/) （浮点数二分答案）
[洛谷 P1873. 砍树](https://www.luogu.com.cn/problem/P1873) 
[洛谷 P2440. 木材加工](https://www.luogu.com.cn/problem/P2440) 
[洛谷 P2678. 跳石头](https://www.luogu.com.cn/problem/P2678) 
[洛谷 P3853. 路标设置](https://www.luogu.com.cn/problem/P3853) 
[洛谷 P1824. 进击的奶牛](https://www.luogu.com.cn/problem/P1824) 
[力扣 274. H 指数](https://leetcode.cn/problems/h-index/) （烧脑预警）
[力扣 875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/) 
[力扣 2594. 修车的最少时间](https://leetcode.cn/problems/minimum-time-to-repair-cars/) 
[牛客 机器人跳跃问题](https://www.nowcoder.com/practice/7037a3d57bbd4336856b8e16a9cafd71) 
[力扣 1552. 两球之间的磁力](https://leetcode.cn/problems/magnetic-force-between-two-balls/) 
[力扣 2560. 打家劫舍 IV](https://leetcode.cn/problems/house-robber-iv/) （二分答案+dp/贪心）

### 特别的二分
[力扣 852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/) 
[力扣 162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/) 
[力扣 1095. 山脉数组中查找目标值](https://leetcode.cn/problems/find-in-mountain-array/) 
[力扣 4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/) 

## 高精度
由于类型限制，计算中使用的数字可能远远超过 `unsigned long long` 所能表达的最大数字，高精度即使用 `string` 或者 ` vector ` 来存储并模拟数字之间的运算，以解决数字过大的问题
### 高精度存储
使用 `vector` 存储，倒序存储数字，倒序是为了方便数位对齐
```cpp
vector<int> read(){
    vector<int> A;
    string x;
    cin >> x;
    for(int i = x.size() - 1; i >= 0; i--){ // 注意方向
        A.push_back(x[i] - '0');
    }
    return A;
}
```

### 高精度比较大小
${A\geq B }$ 返回 `true`，否则返回 `false` 
- 时间复杂度：${O\left( n  \right)  }$，${n }$ 为数字的位数
```cpp
bool ge(vector<int>& A, vector<int>& B){
	if (A.size() != B.size()) return A.size() > B.size();
	for (int i = A.size() - 1; i >= 0; i--)
		if (A[i] != B[i])
			return A[i] > B[i];
	return true; // 等于的情况
}
```

### 高精度加法
- 时间复杂度：${O\left( n \right)  }$，${n }$ 为数字的位数
```cpp
vector <int> add(vector<int>& A, vector<int>& B){
	vector<int> C;
	int r = 0;//存储来自上一位的进位
	for (int i = 0; i < A.size() || i < B.size(); i++){
		if (i < A.size()) r += A[i];
		if (i < B.size()) r += B[i];
		C.push_back(r % 10);
		r /= 10;
	}
	if (r) C.push_back(r);
	return C;
}
```

题目：
[acwing 791. 高精度加法](https://www.acwing.com/problem/content/793/) 
[洛谷 P1601.A+B Problem（高精）](https://www.luogu.com.cn/problem/P1601) 
[洛谷 P1604.B 进制星球](https://www.luogu.com.cn/problem/P1604) （其他进制下的高精度）
[洛谷 P1009. 阶乘之和](https://www.luogu.com.cn/problem/P1009) （高精度加+高精度乘低精度）
[力扣 66. 加一](https://leetcode.cn/problems/plus-one/) 
[力扣 67. 二进制求和](https://leetcode.cn/problems/add-binary/) 

### 高精度减法
请确保 ${A\geq B }$ 
- 时间复杂度：${O\left( n \right)  }$，${n }$ 为数字的位数
```cpp
vector <int> sub(vector<int>& A, vector<int>& B)//A > B{
	vector<int>C;
	int r = 0;//记录上一位是否有借位
	for (int i = 0; i < A.size(); i++){
		r = A[i] - r;
		if (i < B.size()) r -= B[i];
		C.push_back((r + 10) % 10);
		r = r < 0 ? 1 : 0;
	}
	while (C.size() > 1 && C.back() == 0) C.pop_back();
	return C;
}
```

题目：
[acwing 792. 高精度减法](https://www.acwing.com/problem/content/794/) 
[洛谷 P2142. 高精度减法](https://www.luogu.com.cn/problem/P2142) 

### 高精度乘法
#### 高精度乘以低精度
- 时间复杂度：${O\left( n \right)  }$，${n }$ 为高精度数字的位数
```cpp
vector<int> mul(vector <int>& A, int& b){
	vector<int>C;
	int r = 0;
	for (int i = 0; i < A.size(); i++){
		r += A[i] * b;
		C.push_back(r % 10);
		r /= 10;
	}
	while (r) C.push_back(r % 10), r /= 10;
	while (C.size() > 1 && C.back() == 0) C.pop_back();
	return C;
}
```

题目：
[acwing 793. 高精度乘法](https://www.acwing.com/problem/content/795/) 
[洛谷 P1591. 阶乘数码](https://www.luogu.com.cn/problem/P1591) 
[洛谷 P1009. 阶乘之和](https://www.luogu.com.cn/problem/P1009) （高精度加+高精度乘低精度）

#### 高精度乘以高精度
- 时间复杂度：${O\left( n^{2}  \right)  }$，${n }$ 为数字的位数
```cpp
vector<int> mul(vector<int> &A, vector<int> &B) {
    vector<int> C(A.size() + B.size());
    for (int i = 0; i < A.size(); i++) {
        for (int j = 0; j < B.size(); j++) {
            C[i + j] += A[i] * B[j];
        }
    }
    for (int i = 0; i < C.size(); i++) {
        if(i + 1 < C.size()) C[i + 1] += C[i] / 10;
        C[i] %= 10;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

题目：
[洛谷 P1303. A\*B Problem](https://www.luogu.com.cn/problem/P1303) 

### 高精度除法
高精度除以低精度，返回商，`r` 为余数
- 时间复杂度：${O\left( n^{2}  \right)  }$，${n }$ 为数字的位数
```cpp
vector<int> div(vector<int>& A, int& b, long long &r){
	vector<int>C;
	r = 0; // 记录上一位的余数
	for (int i = A.size() - 1; i >= 0; i--){
		r = r * 10 + A[i]; // r使用long long是由于这里可能爆int
		C.push_back(r / b);
		r %= b;
	}
	reverse(C.begin(), C.end()); // 记得翻转回来
	while (C.size() > 1 && C.back() == 0) C.pop_back();
	return C;
}
```

题目：
[acwing 794. 高精度除法](https://www.acwing.com/problem/content/796/) 
[洛谷 P1480. A/B Problem](https://www.luogu.com.cn/problem/P1480) 

## 前缀和
### 一维前缀和
快速查询一段区间内的和（异或也行）
注意：为了方便，通常前缀和与差分从下标 ${1 }$ 开始存储
- 时间复杂度：构造 ${O\left( n \right)  }$，查询 ${O\left( 1 \right)  }$ 

构造：
```cpp
// s[i] = a[1] + a[2] + ... + a[i]
for (int i = 1; i <= n; i++){
	s[i] = s[i - 1] + a[i];
}
```
查询区间 ${\left[ l,r \right]  }$ 的和：
```cpp
sum = s[r] - s[l - 1];
```


题目：
[acwing 795. 前缀和](https://www.acwing.com/problem/content/description/797/) 
[力扣 303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/) 
[洛谷 P8218 求区间和](https://www.luogu.com.cn/problem/P8218) 
[力扣 724. 寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/) 
[洛谷 P5638. 光骓者的荣耀](https://www.luogu.com.cn/problem/P5638) 
[力扣 848. 字母移位](https://leetcode.cn/problems/shifting-letters/) 
[力扣 1423. 可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/) （双指针/前缀和）
[力扣 134. 加油站](https://leetcode.cn/problems/gas-station/) （前缀和 + 贪心）
[力扣 1310. 子数组异或查询](https://leetcode.cn/problems/xor-queries-of-a-subarray/) （前缀异或和）
[力扣 3096. 得到更多分数的最少关卡数目](https://leetcode.cn/problems/minimum-levels-to-gain-more-points/) 

### 二维前缀和
快速查询一个二维区域内的和
注意：为了方便，通常前缀和与差分从下标 ${1 }$ 开始存储
- 时间复杂度：构造 ${O\left( nm \right)  }$，查询 ${O\left( 1 \right)  }$ 

构造：
![image.png|267](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202402112347996.png)

```cpp
// s[i][j]表示左上角点(1,1)到右下角点(i,j)所围成的矩形内的数的和
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
        s[i][j] = s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1] + a[i][j];
```
查询以 `(x1, y1)` 为左上角, `(x2, y2)` 为右下角组成的矩形内的和：
![image.png|286](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202402112353024.png)

```cpp
sum = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]
```

题目：
[acwing 796.子矩阵的和](https://www.acwing.com/problem/content/798/) 
[力扣 304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/) 
[力扣 1314. 矩阵区域和](https://leetcode.cn/problems/matrix-block-sum/) 
[洛谷 P2004. 领地选择](https://www.luogu.com.cn/problem/P2004) 
[洛谷 P2280. 激光炸弹](https://www.luogu.com.cn/problem/P2280) 
[力扣 1139. 最大的以 1 为边界的正方形](https://leetcode.cn/problems/largest-1-bordered-square/) 
[力扣 2132. 用邮票贴满网格图](https://leetcode.cn/problems/stamping-the-grid/) （二维前缀和 + 二维差分）


### 前缀和应用模型
#### 求区间中两个元素的数量差
一串序列只有 ${A,B }$ 两种值，令 ${A }$ 为 $1$，${B }$ 为 $-1$，求其前缀和数组。则 ${s\left[ i \right]  }$ 表示在区间 ${\left[ 1,i \right]  }$ 中 ${A }$ 比 ${B }$ 多 ${s\left[ i \right]  }$ 个。那么 ${s\left[ r \right] -s\left[ l -1\right]  }$ 表示区间 ${\left[ l,r \right]  }$ 中 ${A }$ 比 ${B }$ 多多少个。


一串序列只有 ${A,B }$ 两种值，求一段最长的子区间使得其中 ${A }$ 与 ${B }$ 的数量相等
若 ${s\left[ r \right] -s\left[ l-1 \right] =0 }$ 说明在区间 ${\left[ l,r \right]  }$ 中，${A }$ 和 ${B }$ 的个数相等。题目变成求 ${l }$ 和 ${r }$ 使得该等式成立，该问题变为两数之和问题。使用哈希表记录某个数第一次出现的位置，再遍历数组即可。
- 时间复杂度：${O\left( n \right)  }$ 
题目：
[洛谷 P1114."非常男女"计划](https://www.luogu.com.cn/problem/P1114) （前缀和 + 哈希表）
[力扣 525. 连续数组](https://leetcode.cn/problems/contiguous-array/) （前缀和 + 哈希表）

#### 简化区间公式
利用前缀和数组将区间和操作变为两个数的操作以简化所求公式
[牛客 未排序数组中累加和为给定值的最长子数组长度](https://www.nowcoder.com/practice/36fb0fd3c656480c92b569258a1223d5) （前缀和 + 哈希表）
[牛客 未排序数组中累加和为给定值的最长子数组系列问题补1](https://www.nowcoder.com/practice/545544c060804eceaed0bb84fcd992fb) （前缀和 + 哈希表）
[力扣 560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/) （前缀和 + 哈希表）
[力扣 1124. 表现良好的最长时间段](https://leetcode.cn/problems/longest-well-performing-interval/) （前缀和 + 哈希表）
[力扣 1590. 使数组和能被 P 整除](https://leetcode.cn/problems/make-sum-divisible-by-p/) （前缀和 + 哈希表 + 求余原理）

#### 前缀异或和的应用
[力扣 1371. 每个元音包含偶数次的最长子字符串](https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/) （前缀异或和 + 哈希表）
[力扣 2588. 统计美丽子数组数目](https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/) （前缀异或和 + 哈希表）

### 前缀最值
[力扣 2908. 元素和最小的山形三元组 I](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/) 
[力扣 121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/) （线性 DP / 贪心  + 前缀最值）
[力扣 42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/) （前缀最值 / 双指针）

## 差分
### 一维差分
快速给一段区间全部加上或减去同一个数
注意：为了方便，通常前缀和与差分从下标 ${1 }$ 开始存储
- 时间复杂度：构造 ${O\left( n \right)  }$，修改 ${O\left( 1 \right)  }$，还原 ${O\left( n \right)  }$ 

构造：
```cpp
// 开两个数组：
for (int i = 1; i <= n; i++){
	cin >> a[i];
	d[i] = a[i] - a[i - 1];
}

// 原地差分：
// 1.输入与求差分分离
for(int i = n; i >= 1; i--){
	cin >> a[i];
}
for(int i = n; i >= 1; i--){ // （从后往前！）
	a[i] -= a[i - 1];
}
// 2.边输入边差分
for(int i = 1; i <= n; i++){
	int x;
	cin >> x;
	a[i] += x;
	a[i + 1] -= x;
}
```
修改（在区间 ${\left[ l,r \right]  }$ 全部加上 ${x }$）：
```cpp
d[l] += x;
d[r + 1] -= x;
```
还原：
```cpp
for (int i = 1; i <= n; i++){
	d[i] += d[i - 1];
} 
```

题目：
[acwing 797. 差分](https://www.acwing.com/problem/content/799/) 
[洛谷 P2367 语文成绩](https://www.luogu.com.cn/problem/P2367) 
[力扣 1094. 拼车](https://leetcode.cn/problems/car-pooling/) 
[力扣 1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/) 
[acwing 2041. 干草堆](https://www.acwing.com/problem/content/description/2043/) （差分 + 快速选择）
[洛谷 P3406. 海底高铁](https://www.luogu.com.cn/problem/P3406) 
[力扣 1589. 所有排列中的最大和](https://leetcode.cn/problems/maximum-sum-obtained-of-any-permutation/) （贪心 + 差分）

### 二维差分
快速给一个二维区域全部加上或减去同一个数
注意：为了方便，通常前缀和与差分从下标 ${1 }$ 开始存储
- 时间复杂度：构造 ${O\left( nm \right)  }$，修改 ${O\left( 1 \right)  }$，还原 ${O\left ( nm\right)  }$ 

构造：
```cpp
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
        insert(i, j, i, j, a[i][j]);
```

修改（以 `(x1, y1)` 为左上角，`(x2, y2)` 为右下角的区域内全部加上 ${x }$）：
![image.png|279](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202402120001162.png)

```cpp
void insert(int x1, int y1, int x2, int y2, int x){
    d[x1][y1] += x;
    d[x2 + 1][y1] -= x;
    d[x1][y2 + 1] -= x;
    d[x2 + 1][y2 + 1] += x;
}
```
还原：
![image.png|267](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202402112347996.png)
```cpp
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
        d[i][j] += d[i][j - 1] + d[i - 1][j] - d[i - 1][j - 1];
```

题目：
[acwing 798. 差分矩阵](https://www.acwing.com/problem/content/800/) 
[洛谷 P3397. 地毯](https://www.luogu.com.cn/problem/P3397) 
[acwing 3203. 画图](https://www.acwing.com/problem/content/3206/) 
[力扣 2132. 用邮票贴满网格图](https://leetcode.cn/problems/stamping-the-grid/) （二维前缀和 + 二维差分）

### 差分应用模型
给一个序列，每次操作可以使某段区间全部减 ${1 }$，求使得序列全部变为 $0$ 的最少操作次数

解法：求其差分数组，原数组的一个区间操作操作对应差分数组一个 $-1$ 和一个 $+1$ 操作。全 $0$ 数组的差分数组也是全 $0$，要将原数组通过区间操作变为全 $0$ 即将差分数组通过 $-1$ 和 $+1$ 操作变为全 $0$。所以只需要求差分数组中大于 $0$ 的数的和即可
- 时间复杂度：${O\left( n \right)  }$ 
```cpp
for (int i = 1; i <= n; i++)
	if (a[i] > a[i - 1])
		ans += a[i] - a[i - 1];
```

题目：
[洛谷 P1969. 积木大赛](https://www.luogu.com.cn/problem/P1969) 
[洛谷 P5019. 铺设道路](https://www.luogu.com.cn/problem/P5019) 


## 双指针
### 单向移动
#### 维护指针与探索指针
- 时间复杂度：${O\left( n \right)  }$ 
- 空间复杂度：${O\left( 1 \right)  }$ 
```cpp
// 模板
for(int i = 0, j = 0; j < n; j++){
	// i 是维护指针，左边维护满足条件的区间
    // j 是探索指针，找到第一个与a[i]交换后能保持区间条件的数
    while(j < n && a[j]与a[i]交换后不能保持区间条件) j++;
    if(j < n){
	    swap(a[i], a[j]);
	    i++;
    }
}
```
[力扣 27. 移除元素](https://leetcode.cn/problems/remove-element/) 
[acwing 2816. 判断子序列](https://www.acwing.com/problem/content/2818/) 
[力扣 283. 移动零](https://leetcode.cn/problems/move-zeroes/) 
[力扣 26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/) 
[acwing 425. 明明的随机数](https://www.acwing.com/problem/content/427/) 
[力扣 80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/) 
[力扣 922. 按奇偶排序数组 II](https://leetcode.cn/problems/sort-array-by-parity-ii/) 

#### 快慢指针
通常快慢指针用于寻找入环节点
快慢指针同时从起点出发，快指针一次走两步，慢指针一次走一步，当两个指针第一次相遇时，将慢指针传送回起点。之后快慢指针每次都只走一步，再次相遇的位置即是入环点
- 时间复杂度：${O\left( n \right)  }$ 
- 空间复杂度：${O\left( 1 \right)  }$ 
```cpp
fast = begin, slow = begin;
while(true){
	if(fast 或者 slow走到头) return NULL; //  无环
	slow = slow->next;
	fast = fast->next->next;
	if(slow == fast){ // 有环，开始寻找入环节点
		slow = begin;
		while(slow != fast){
			slow = slow->next;
			fast = fast->next;
		}
		return fast;
	}
}
```
[力扣 141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/) 
[力扣 142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/) 
[力扣 287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/) 

#### 滑动窗口（尺取法）
通常用于求解连续子串问题，要求子串满足某种条件
范围和条件指标有单调关系
```cpp
// 区间满足要求时收缩（区间越长越容易满足要求）
for(int l = 0, r = 0; r < n; r++){
	右边界扩展维护区间
	while(l <= r && 区间[l, r]满足要求){
		更新答案
		左边界收缩维护区间
		l++;
	}
}
```
[力扣 209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/) 
[洛谷 P1638 逛画展](https://www.luogu.com.cn/problem/P1638) 
[力扣  1234. 替换子串得到平衡字符串](https://leetcode.cn/problems/replace-the-substring-for-balanced-string/) 
[力扣 76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/) 
[洛谷 P2698 Flowerpot S](https://www.luogu.com.cn/problem/P2698) （滑动窗口 + 单调队列）

```cpp
// 区间不满足要求时收缩（区间越长越不容易满足要求）
for(int l = 0, r = 0; r < n; r++){
	右边界扩展维护区间
	while(l <= r && 区间[l,r]不满足要求){
		左边界收缩维护区间
		l++;
	}
	更新答案
}
```
[acwing 799. 最长连续不重复子序列](https://www.acwing.com/problem/content/801/) 
[力扣 3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/) 
[力扣 904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/) 
[力扣 1695. 删除子数组的最大得分](https://leetcode.cn/problems/maximum-erasure-value/) 
[力扣 1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/) 
[力扣 2024. 考试的最大困扰度](https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/) 
[力扣 992. K 个不同整数的子数组](https://leetcode.cn/problems/subarrays-with-k-different-integers/) 
[力扣 1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/) （滑动窗口 + 单调队列）
[力扣 713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/) 
[力扣 1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/) 
[力扣 2516. 每种字符至少取 K 个](https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/) 

#### 固定长度滑动窗口
```cpp
for(int l = 0, r = l + k - 1; r < n; l++, r++){
	处理区间[l, r]
}
```
[力扣 19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) 
[力扣 61. 旋转链表](https://leetcode.cn/problems/rotate-list/) 
[力扣 1423. 可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/) （双指针 / 前缀和）

```cpp
for(int l = 0, r = 0; r < n; r++){
	右边界扩展代码 
	if(r - l + 1 == k){
		if(区间[l,r]满足条件) 记录答案;
		左边界收缩代码
		l++;
	}
}
```
[力扣 438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) 
[力扣 567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/) 

### 两边收缩
[力扣 27. 移除元素](https://leetcode.cn/problems/remove-element/) 
[力扣 344. 反转字符串](https://leetcode.cn/problems/reverse-string/)
[力扣 345. 反转字符串中的元音字母](https://leetcode.cn/problems/reverse-vowels-of-a-string/) 
[力扣 881. 救生艇](https://leetcode.cn/problems/boats-to-save-people/) 
[力扣 977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/) 

#### 盛最多水的容器
[力扣 11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)（贪心 + 双指针）

#### 接雨水
[力扣 42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/) （前缀最值 / 双指针）

#### 左右维护
[力扣 75. 颜色分类](https://leetcode.cn/problems/sort-colors/) 


#### 两个有序数组有序矩阵上的双指针
以下都是一类题，具有潜在的共通点
[acwing 800. 数组元素的目标和](https://www.acwing.com/problem/content/802/) 
[acwing 1532. 找硬币](https://www.acwing.com/problem/content/1534/) 
[力扣 167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/) 
[力扣 633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/) 
[力扣 LCR 179. 查找总价格为目标值的两个商品](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/) 
[力扣 LCR 121. 寻找目标值 - 二维数组](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/) 
[力扣 633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/) 
[力扣 240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/) 
[力扣 15. 三数之和](https://leetcode.cn/problems/3sum/) 
```cpp
for(int i = 0, j = m - 1; i < n; i++){
	while(a[i] + b[j] > x) j--; // 随着i往右移动，对应的j只有可能往左移
	if(a[i] + b[i] == x){
		cout << i << " " << j;
		break;
	}
}
```

### 中心扩散
[力扣 5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/) 



## 离散化
离散化就是把一段很长的稀疏区间，映射到连续的一段较小的稠密区间里，具体做法是**将数据排序后映射成下标** 
利用二分查找可以快速查找到原数映射后的位置
通常使用在数据值较大（ ${>1e5 }$）而数据量较小（ ${\leq 1e5 }$ ）的时候
- 时间复杂度：构建 ${O\left( n \right)  }$，查询 ${O\left( \log n \right)  }$，${n }$ 是数据量
- 空间复杂度：${O\left( n \right)  }$ 
![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202402122322996.png)

- 时间复杂度：离散化：${O\left( n\log n \right)  }$，查找：${O\left( \log n \right)  }$ 
```cpp
vector<int> a; // 原数组
vector<int> d(a); // 离散化后数组

// 1.排序
sort(d.begin(), d.end());
// 2.去重
d.erase(unique(d.begin(), d.end()), d.end());
// 3.利用二分找到原数字x离散化后的位置（第一个大于等于x的数）
int rank(int x){
	int l = 0, r = d.size() - 1;
	while(l < r){
		int mid = l + r >> 1;
		if(d[mid] >= x) r = mid;
		else l = mid + 1;
	}
	return l;
}
```

题目：
[洛谷 B3694. 数列离散化](https://www.luogu.com.cn/problem/B3694) 
[acwing 802. 区间和](https://www.acwing.com/problem/content/804/) （离散化 + 前缀和）
[力扣 2251. 花期内花的数目](https://leetcode.cn/problems/number-of-flowers-in-full-bloom/) （离散化 + 差分）
[洛谷 P1496 火烧赤壁](https://www.luogu.com.cn/problem/P1496) （离散化 + 差分）


## 区间合并
给定若干区间 ${\left[ l_{i} ,r_{i}  \right]  }$，将所有重叠的区间合并为一个区间
思路：
1. 区间按左边界排序
2. 依次判断相邻两个区间是否可以合并
- 时间复杂度：${O\left( n \right)  }$ （不算上排序）
```cpp
vector<pii> merge(vector<pii> ranges){
	vector<pii> new_ranges;
	sort(ranges.begin(), ranges.end()); // 按左边界排序
	int L = ranges[0].first, R = ranges[0].second;
	for(int i = 1; i < ranges.size(); i++){
		int l = ranges[i].first, r = ranges[i].second;
		if(l <= R){ // 可以合并
			R = max(R, r);
		}
		else{ // 不能合并
			new_ranges.push_back({L, R});
			L = l, R = r;
		}
	}
	new_ranges.push_back({L, R});
	return new_ranges;
}
```

题目：
[acwing 803. 区间合并](https://www.acwing.com/problem/content/805/) 
[力扣 56. 合并区间](https://leetcode.cn/problems/merge-intervals/) 
[acwing 422. 校门外的树](https://www.acwing.com/problem/content/description/424/) 
[力扣 2580. 统计将重叠区间合并成组的方案数](https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/) （区间合并 + 快速幂）
[力扣 2848. 与车相交的点](https://leetcode.cn/problems/points-that-intersect-with-cars/) 
[力扣 3458. 选择 K 个互不重叠的特殊子字符串](https://leetcode.cn/problems/select-k-disjoint-special-substrings/) （区间合并 + 贪心）


## 进制转换
### 字符转换
`0~9`：`0~9` 
`10~15` ：`'A'~'Z'` 
`36~61`：`'a'~'z'` 

```cpp
int ctoi(char x){ // 字符型转换为整型
	if ('0' <= x && x <= '9')return (x - '0');
	if ('A' <= x && x <= 'Z')return (x - 'A' + 10);
	return (x - 'a' + 36);
}

char itoc(int x){ // 整型转换为字符型
	if (0 <= x && x <= 9)return (x + '0');
	if (10 <= x && x <= 35)return (x - 10 + 'A');
	return (x - 36 + 'a');
}
```

### A 进制转 10 进制
```cpp
int baseTo10(string s, int A){
	int res = 0;
	for(int i = 0; i < s.size(); i++){
		res = res * A + ctoi(s[i]);
	}
	return res;
}
```

### 10 进制转 B 进制
```cpp
string baseToB(int x, int B){
	string res;
	while(x){
		res += itoc(x % B);
		x /= B;
	}
	reverse(res.begin(), res.end());
	return res;
}
```

### A 进制转 B 进制
从 A 进制转换为 B $(\le62)$ 进制
```cpp
string changeBase(string s, int A, int B){ // 将s从A进制转换为B进制
	string res;
	while (s.size()){ // 短除法
		int r = 0; // 来自上一位的余数
		for (int i = 0; i < s.size(); i++){
			int t = ctoi(s[i]) + r * A;
			r = t % B;
			s[i] = itoc(t / B);
		}
		res += itoc(r); // 结果加上最后的余数
		int i = 0;
		while (s.size() && s[i] == '0')i++;
		s = s.substr(i); // 去除s的前导0
	}
	reverse(res.begin(), res.end());
	return res;
}
```

题目：
[acwing 124. 数的进制转换](https://www.acwing.com/problem/content/126/) 
[acwing 1346. 回文平方](https://www.acwing.com/problem/content/description/1348/) 

## 单调栈
### 求最近的大于/小于当前数的下标
求序列中每一个数左边最近的大于/小于它的数的下标
思路：一个数入栈之前，判断入栈后是否满足栈内单调性，不满足则栈顶出栈直到满足单调性为止。栈顶就是左边第一个大于/小于待入栈的数。 (要求右边反向遍历即可)
- 时间复杂度：${O\left( n \right)  }$ 
```cpp
// 求左边第一个比a[i]小的数的下标
stack<int> s;
for(int i = 0; i < n; i++){
    // 维护递增栈：栈顶为左边第一个比a[i]小的数的下标
    while(!s.empty() && a[s.top()] >= a[i]) s.pop();
    small[i] = s.empty() ? -1 : s.top();
    s.push(i);
}
```
题目：
[acwing 830. 单调栈](https://www.acwing.com/problem/content/832/) 
[洛谷 P5788.【模板】单调栈](https://www.luogu.com.cn/problem/P5788) 
[acwing 131. 直方图中最大的矩形](https://www.acwing.com/problem/content/133/) 
[力扣 84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/) 
[力扣 85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/) 
[力扣 1793. 好子数组的最大分数](https://leetcode.cn/problems/maximum-score-of-a-good-subarray/) 
[力扣 739. 每日温度](https://leetcode.cn/problems/daily-temperatures/) 
[力扣 901. 股票价格跨度](https://leetcode.cn/problems/online-stock-span/) 
[力扣 907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/) 

### 求最远的大于/小于当前数的下标
求序列中每一个数左边最远的大于/小于它的数的下标
- 时间复杂度：${O\left( n\log n \right)  }$ 
```cpp
// 左边最远<的位置，如要求<=则修改12,15行的符号为<=
// 如要求右边，反向遍历数组即可
vector<int> left(n, 0);
vector<int> s;
for(int i = 0; i < n; i++){
	// 栈中只存储严格递减元素下标
	if(s.empty() || a[i] < a[s.back()]) s.push_back(i);
	
	// 找到第一个<的位置
	int l = 0, r = s.size();
	while(l < r){
	    int mid = l + r >> 1;
	    if(a[s[mid]] < a[i]) r = mid;
	    else l = mid + 1;
	}
	left[i] = a[s[l]] < a[i] ? s[l] : -1; // 如果找不到则存储-1
}
```

```cpp
// 左边最远>的位置，如要求>=则修改12,15行的符号为>=
// 如要求右边，反向遍历数组即可
vector<int> left(n, 0);
vector<int> s;
for(int i = 0; i < n; i++){
	// 栈中只存储严格递增元素下标
	if(s.empty() || a[i] > a[s.back()]) s.push_back(i);
	
	// 找到第一个>的位置
	int l = 0, r = s.size();
	while(l < r){
	    int mid = l + r >> 1;
	    if(a[s[mid]] > a[i]) r = mid;
	    else l = mid + 1;
	}
	left[i] = a[s[l]] > a[i] ? s[l] : -1; // 如果找不到则存储-1
}
```


如果只要求全局最长的长度，则反向遍历数组为栈顶记录答案，每记录一个答案弹出栈即可
- 时间复杂度：${O\left( n \right)  }$ 
```cpp
// 以<=为例
stack<int> s;
for(int i = 0; i < n; i++)
	if(s.empty() || a[i] < a[s.top()]) 
		s.push(i);
int maxlen = -1;
for(int i = n - 1; i >= 0; i--){
	while(!s.empty() && a[s.top()] <= a[i]){
		maxlen = max(maxlen, i - s.top());
		s.pop();
	}
}
```
[力扣 962. 最大宽度坡](https://leetcode.cn/problems/maximum-width-ramp/) 
[力扣 1124. 表现良好的最长时间段](https://leetcode.cn/problems/longest-well-performing-interval/) （前缀和 + 哈希表/单调栈）

### 其他非典型应用
[力扣 316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/) 



## 单调队列
序列中有一个滑动窗口，求滑动窗口中的最大值或者最小值
思路：使用双端队列，一个数从队尾入队之前，判断入队后是否满足单调性，不满足则队尾出队直到满足单调性为止。队头就是滑动窗口的最小值/最大值。窗口缩减时将过期元素从队头弹出即可。
注意队列中存放的是下标不是数字，存下标是为了知道队首元素是否过期
- 时间复杂度：整体 ${O\left( n \right)  }$ ，询问 ${O\left( 1 \right)  }$ 
```cpp
// 维护窗口中的最小值
for(int i = 0; i < n; i++){
    // 维护递增队列，队列中存储的是下标，队头元素即为窗口中最小值
    while(!q.empty() && a[q.back()] >= a[i]) q.pop_back();
    q.push_back(i);
    if(i - q.front() + 1 > k) q.pop_front(); // 删除过期元素
    if (i + 1 >= k) cout << a[q.front()] << " ";
}
```

题目：
[acwing 154. 滑动窗口](https://www.acwing.com/problem/content/156/) 
[洛谷 P1886. 滑动窗口/【模板】单调队列](https://www.luogu.com.cn/problem/P1886) 
[LCR 183. 望远镜中最高的海拔](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/) 
[洛谷 P2032 扫描](https://www.luogu.com.cn/problem/P2032) 
[力扣 239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/) 
[力扣 1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/) （滑动窗口 + 单调队列）
[洛谷 P2698 Flowerpot S](https://www.luogu.com.cn/problem/P2698) （滑动窗口 + 单调队列）

### 其他非典型应用
[力扣 862. 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/) （前缀和 + 单调队列）


## KMP
找到模式串 ${p }$ 在主串 ${s }$ 中出现的位置
${next\left[ i \right]  }$：在 ${p\left[ 1 \right] \sim p\left[ i \right]  }$ 的子串中，前缀 ${= }$ 后缀的最长长度
![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202402152219929.png)
- 时间复杂度：${O\left( n+m \right)  }$ 
- 空间复杂度：${O\left( m \right)  }$ 
```cpp
// 求next数组
for(int i = 1, k = 0; i < p.size(); i++){ // 注意从i从1开始，因为前后缀不能是同一串
    while(k != 0 && p[i] != p[k]) k = nxt[k - 1];
    if(p[i] == p[k]) k++;
    nxt[i] = k;
}
```
```cpp
// 进行匹配
for(int i = 0, j = 0; i < s.size(); i++){
	// i指向主串s，j指向模式串p
	while(j != 0 && s[i] != p[j]) j = nxt[j - 1];
	if(s[i] == p[j]) j++;
	if(j == p.size()){// 匹配成功输出位置
		cout << i - j + 1 << " ";
		j = nxt[j - 1]; // 如果还想继续匹配则加上这句
	}
}
```
题目：
[acwing 831. KMP 字符串](https://www.acwing.com/problem/content/833/) 
[洛谷 P3375.【模板】KMP](https://www.luogu.com.cn/problem/P3375) 

## 并查集（DSU）
并查集有两个操作：将两个集合合并，查询两个元素是否在同一集合
常用于判断连通性
- 时间复杂度：合并 ${\approx O\left( 1 \right)  }$，查询 ${\approx O\left( 1 \right)  }$ 
- 空间复杂度：${O\left( n \right)  }$，${n }$ 为节点数量
```cpp
// 基础版
struct dsu{
    int f[N]; // 每个元素的父亲节点
    void init(int n){ // 初始化
        for(int i = 1; i <= n; i++){
            f[i] = i; // 每一个元素，其父亲节点为它本身
        }
    }
    int anc(int x){ // 找祖先，使用路径压缩优化
        if(f[x] != x) f[x] = anc(f[x]);
        return f[x];
    }
    void merge(int a, int b){ // 合并,将后一元素祖先的父节点设置为前一元素祖先
        f[anc(b)] = anc(a);
    }
    bool query(int a, int b){ // 判断是否是同一族
        return anc(a) == anc(b);
    }
};
```

### 维护额外信息
并查集还支持维护每个集合中的信息（如集合中元素的数量），以及所有集合的信息（如集合数量）
```cpp
// 维护每个集合中元素个数，以及维护集合总数
struct dsu{
    int f[N]; // 每个元素的父亲节点
    int size[N]; // 维护每个集合中元素个数
    int setnum = 0; // 维护集合总数
    void init(int n){ // 初始化
        for(int i = 1; i <= n; i++){
            f[i] = i; // 每一个元素，其父亲节点为它本身
            size[i] = 1; // 集合中元素为1
        }
        setnum = n; // 集合数量为n
    }
    int anc(int x){ // 找祖先，使用路径压缩优化
        if(f[x] != x) f[x] = anc(f[x]);
        return f[x];
    }
    void merge(int a, int b){ // 合并,将后一元素祖先的父节点设置为前一元素祖先
        if(anc(a) != anc(b)){
	        size[anc(a)] += size[anc(b)]; // 合并后集合元素相加
            f[anc(b)] = anc(a);
            setnum--; // 集合数量减一
        }
    }
    bool query(int a, int b){ // 判断是否是同一族
        return anc(a) == anc(b);
    }
    int elenum(int x){ // x所在集合中元素数量
	    return size[anc(x)];
    }
};
```

题目：
[acwing 836. 合并集合](https://www.acwing.com/problem/content/838/) 
[洛谷 P3367.【模板】并查集](https://www.luogu.com.cn/problem/P3367) 
[牛客 并查集的实现](https://www.nowcoder.com/practice/e7ed657974934a30b2010046536a5372) 
[洛谷 P1551. 亲戚](https://www.luogu.com.cn/problem/P1551) 
[洛谷 P1536. 村村通](https://www.luogu.com.cn/problem/P1536) （维护集合总数）
[力扣 839. 相似字符串组](https://leetcode.cn/problems/similar-string-groups/) （维护集合总数）
[洛谷 P1111. 修复公路](https://www.luogu.com.cn/problem/P1111) （维护集合总数）
[acwing 837. 连通块中点的数量](https://www.acwing.com/problem/content/839/) （维护每个集合中元素个数）
[力扣 2316. 统计无向图中无法互相到达点对数](https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/) （维护每个集合中元素个数）
[力扣 947. 移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/) （维护每个集合中元素个数）
[洛谷 P3958. 奶酪](https://www.luogu.com.cn/problem/P3958) （维护每个集合中最高和最低位置）
[力扣 2092. 找出知晓秘密的所有专家](https://leetcode.cn/problems/find-all-people-with-secret/) （维护每个集合是否知道秘密）
[力扣 2421. 好路径的数目](https://leetcode.cn/problems/number-of-good-paths/) （维护集合中最大值的数量）
[力扣 928. 尽量减少恶意软件的传播 II](https://leetcode.cn/problems/minimize-malware-spread-ii/) （维护集合中的元素以及感染源头）
[洛谷 P1197. 星球大战 ](https://www.luogu.com.cn/problem/P1197) （离线逆向 + 并查集）
[acwing 5840. 封印序列](https://www.acwing.com/problem/content/5843/) （离线逆向 + 并查集维护每个区间的和）
[力扣 765. 情侣牵手](https://leetcode.cn/problems/couples-holding-hands/) （置换群 + 并查集）
[力扣 1697. 检查边长度限制的路径是否存在](https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/) (并查集 + 离线查询)

### 带权并查集
[acwing 240. 食物链](https://www.acwing.com/problem/content/242/) 

### 区间染色模型
[acwing 3115. 疯狂的馒头](https://www.acwing.com/problem/content/description/3118/) 


## 字符串哈希
获取字符串的哈希值，判断两个子串是否相同
思路：把字符串看作一个 ${P }$ 进制数，对其取模得到哈希值（经验值： ${P }$ 取 ${131,13331 }$，模数取 ${2^{64}  }$，使用 `unsigned long long` 类型时数据溢出相当于对 ${2^{64}  }$ 取模，因此不需要额外取模了）
任意区间字符串的哈希值可以由前缀字符串的哈希值计算得到

- 时间复杂度：构造前缀哈希表 ${O\left( n \right)  }$，获取子串哈希值 ${O\left( 1 \right)  }$ 
${h\left[ i \right]  }$ 表示字符串长度为 ${i }$ 的前缀字符串的哈希值
${p\left[ i \right]  }$ 表示 ${p^{i}  }$，可以用数组预处理出来
```cpp
typedef unsigned long long ULL;
const int P = 131;//经验值
ULL h[N], p[N] = { 1 }; // h是前缀哈希表，p[i]表示p的i次方

// 前缀哈希表生成
for(int i = 1; i <= s.size(); i++){
    h[i] = h[i - 1] * P + s[i - 1];
    p[i] = p[i - 1] * P;
}

// 得到从l到r间字符串的哈希值
ULL gethash(int l, int r){
	return h[r] - h[l - 1] * p[r - l + 1];
}
```

题目：
[acwing 841. 字符串哈希](https://www.acwing.com/problem/content/843/) 
[洛谷 P3370. 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370) 

## 搜索
### 深度优先搜索 DFS
- 时间复杂度：${O\left( b^{m}  \right)  }$，${b }$ 是搜索树的最大分支因子，${m }$ 是状态空间的最大深度
```cpp
void dfs(深度x/路径数据){
    if(搜索结束条件){
        处理搜索到最深处的情况
        return;
    }
    for(枚举所有可能的值){
        if(当前值可以被选取){
            vis[i] = true; // 记录该值已经被选取
            dfs(x + 1); // 搜索下一层
            vis[i] = false; // 释放当前值
        }
    }
}
```

题目：
[力扣 78. 子集](https://leetcode.cn/problems/subsets/) 
[力扣 90. 子集 II](https://leetcode.cn/problems/subsets-ii/) 
[力扣 46. 全排列](https://leetcode.cn/problems/permutations/) 
[acwing 842. 排列数字](https://www.acwing.com/problem/content/844/) 
[洛谷 P1706. 全排列问题](https://www.luogu.com.cn/problem/P1706) 
[力扣 47. 全排列 II](https://leetcode.cn/problems/permutations-ii/) 
[力扣 784. 字母大小写全排列](https://leetcode.cn/problems/letter-case-permutation/) 
[力扣 77. 组合](https://leetcode.cn/problems/combinations/) 
[力扣 39. 组合总和](https://leetcode.cn/problems/combination-sum/) 
[力扣 40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/) 
[力扣 216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/) 
[acwing 845. n-皇后问题](https://www.acwing.com/problem/content/845/) 
[acwing 1432. 棋盘挑战](https://www.acwing.com/problem/content/description/1434/) 
[洛谷 P1784. 数独](https://www.luogu.com.cn/problem/P1784) 
[洛谷 P1219. 八皇后](https://www.luogu.com.cn/problem/P1219) 
[洛谷 P1605. 迷宫](https://www.luogu.com.cn/problem/P1605) 
[洛谷 P1596. Lake Counting S](https://www.luogu.com.cn/problem/P1596) 
[洛谷 P2404. 自然数的拆分问题](https://www.luogu.com.cn/problem/P2404) 
[力扣 2684. 矩阵中移动的最大次数](https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/) 
[力扣 79. 单词搜索](https://leetcode.cn/problems/word-search/) 
[力扣 131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/) 

### 广度优先搜索 BFS
广度优先搜索天然有最优性，常应用于求最少步数的题
```cpp
queue <int> q;
q.push(初始状态);
vis[初始状态] = 1; // 标记初始状态已经被访问
while(!q.empty()){
	s = q.front(); // 提取队头元素
	q.pop(); // 队头元素出栈
    for(枚举所有可能的下一个操作i){
        next = f(s, i); //根据当前状态算得下一个状态
    	if(下一个状态next可以被选取){
        	q.push(next)
            vis[next]=1;//标记被访问
    	}
    }
}
```

题目：
[acwing 844. 走迷宫](https://www.acwing.com/problem/content/846/) 
[洛谷 P1162. 填涂颜色]( https://luogu.com.cn/problem/P1162 ) 
[洛谷 P1443. 马的遍历](https://www.luogu.com.cn/problem/P1443) 
[acwing 845. 八数码](https://www.acwing.com/problem/content/847/) 
[洛谷 P1135. 奇怪的电梯](https://www.luogu.com.cn/problem/P1135) 
[洛谷 P1141. 01迷宫](https://www.luogu.com.cn/problem/P1141) 
[洛谷 P1126. 机器人搬重物](https://www.luogu.com.cn/problem/P1126) 
[acwing 1101. 献给阿尔吉侬的花束](https://www.acwing.com/problem/content/1103/) 

#### 多源 bfs
从多个源点出发的广度优先搜索，只需要在队列初始化时将多个源点加入队列即可

题目：
[力扣 1162. 地图分析](https://leetcode.cn/problems/as-far-from-land-as-possible/) 
[力扣 407. 接雨水 II](https://leetcode.cn/problems/trapping-rain-water-ii/) （bfs+堆）


### 双向搜索
又称折半搜索，meet in the middle，指将整个搜索过程分为两部分，并对两部分分别进行搜索，最多得到两个答案序列，将这两个答案序列进行合并即可得到最终答案。
如果每层搜索都有两种选择，那么 ${n }$ 层搜索的时间复杂度为 ${O\left( 2^{n}  \right)  }$，如果使用折半搜索，则时间复杂度为 ${O\left( 2^{\frac{n}{2} } +k \right)  }$，其中 ${k }$ 指将两个答案序列合并的时间复杂度


题目：
[洛谷 P4799【CEOI 2015】世界冰球锦标赛 (Day2)](https://www.luogu.com.cn/problem/P4799) 


### 洪水灌溉 Flood Fill
在二维上遍历联通块
使用 dfs 实现更方便，使用 bfs 则可以求最短路径

BFS 实现
```cpp
vis[N][M] = 0;
int dx[] = {-1, 0, 1, 0}; // 下右上左
int dy[] = {0, 1, 0, -1}; // 下右上左

queue<PII> q;

void bfs(){
	q.push(起点)
	vis[起点] = true;
	ans++; // 答案最好统一在入队时记录
	
	while(!q.empty()){
		PII s = q.front();
		q.pop();
		for(int i = 0; i < 4; i++){
			int nx = s.first + dx[i];
			int ny = s.second + dy[i];
			if(nxny没有出界 && !vis[nx][ny] && mp[nx][ny]可以访问){
				q.push({nx, ny});
				vis[nx][ny] = true;
				ans++;
			}
		}
	}
}
```

DFS 实现
```cpp
vis[N][M] = 0;
int dx[] = {-1, 0, 1, 0}; // 下右上左
int dy[] = {0, 1, 0, -1}; // 下右上左

void dfs(int x, int y){
	vis[x][y] = true;
	for(int i = 0; i <4; i++){
		int nx = s.first + dx[i];
		int ny = s.second + dy[i];
		if(nxny没有出界 && !vis[nx][ny] && mp[nx][ny]可以访问)
			dfs(nx, ny);
	}
	return;
}
```

题目：
[acwing 1113. 红与黑](https://www.acwing.com/problem/content/description/1115/) 
[力扣 200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/) 
[力扣 130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/) 
[力扣 827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/) 

### 格子世界搜索
以下是格子世界搜索的常用代码技巧
```cpp
// 四个方向的偏移数组
int dx[] = {0, 1, 0, -1}
int dy[] = {-1, 0, 1, 0}

// 检查x, y是否合法
bool check(int x, int y){
	return 0 <= x && x < n && 0 <= y && y < n;
}

// 枚举搜索每个方向
for(int d = 0; d < 4; d++){
	// 计算下一个位置
	nx = x + dx[d];
	ny = y + dy[d];
	// 检查下一个位置是否越界
	check(nx, ny);
}

```

题目：
[力扣 1958. 检查操作是否合法](https://leetcode.cn/problems/check-if-move-is-legal/) 
[力扣 463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/) 
[力扣 1222. 可以攻击国王的皇后](https://leetcode.cn/problems/queens-that-can-attack-the-king/) 


## 快速幂
用来快速计算 ${a^{b} \%p }$  
$$
a^{n}=\begin{cases} a^{\frac{n}{2}} \times a^{\frac{n}{2} } &\left( n 是偶数 \right) \\ a^{n-1} \times a&\left( n是奇数 \right)  \end{cases}
$$

- 时间复杂度：${O\left( \log b \right)  }$ 
```cpp
int quick_power(int a, int b, int p){
    long long res = 1, t = a;
    while (b){
        if (b & 1) res = res * t % p;
        t = t * t % p;
        b >>= 1;
    }
    return res % p;
}
```

题目：
[acwing 875. 快速幂](https://www.acwing.com/problem/content/877/) 
[acwing 89. a^b](https://www.acwing.com/problem/content/91/) 
[力扣 50. Pow(x, n)](https://leetcode.cn/problems/powx-n/) 
[力扣 1969. 数组元素的最小非零乘积](https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/) 

## 摩尔投票
用于求数组中的众数（出现次数超过一半的元素）
- 时间复杂度：${O\left( n \right)  }$ 
- 空间复杂度：${O\left( 1 \right)  }$ 
```cpp
int winner, votes = 0;
for(int x : nums){
    if(votes == 0) winner = x; // 票数为0则换人
    votes += (x == winner ? 1 : -1);
}
```

题目：
[169. 多数元素](https://leetcode.cn/problems/majority-element/) 

# 进阶算法
## 等差数列差分
在 ${\left[ l,r \right]  }$ 范围上加上首项为 ${s }$，公差为 ${d }$，末项为 ${e }$ 的等差数列
修改：${O\left( 1 \right)  }$ 
```cpp
void add(int l, int r, int s, int e, int d){
	// e = s + (r - l) * d
	// d = (e - s) / (r - l)
	a[l] += s;
	a[l + 1] += d - s;
	a[r + 1] -= d + e;
	a[r + 2] += e;
}
```
还原：${O\left( n \right)  }$ 
```cpp
// 两遍前缀和
for(int i = 1; i <= n; i++){
	a[i] += a[i - 1];
}
for(int i = 1; i <= n; i++){
	a[i] += a[i - 1];
}
```

题目：
[洛谷 P4231 三步必杀](https://www.luogu.com.cn/problem/P4231) 
[洛谷 P5026 Lycanthropy](https://www.luogu.com.cn/problem/P5026) 

## 求非负序列子集的前 k 小和
已知递增非负序列 ${a_{0} ,a_{1} ,\cdots ,a_{n}  }$，求其所有子集中（不包括空集）最小的前 ${k }$ 个和

小根堆存储两个关键字 ${\left\{ sum,i \right\}  }$ 表示子集总和为 ${sum }$ 且子集的最后一个元素下标为 ${i }$ 
执行 ${k }$ 次：
1. 每次将堆顶弹出 (假设堆顶所表示的集合为 ${\left[ a,b,c \right]  }$，${c }$ 的下标为 ${i }$，${d }$ 的下标为 ${i+1 }$ )
2. 将最后一个元素替换为 ${d }$ 后的集合入堆，即将 ${\left[ a,b,d \right]  }$ 入堆
3. 将元素 ${d }$ 加入集合后的集合入堆，即将 ${\left[ a,b,c,d \right]  }$ 入堆
- 时间复杂度：${O\left( k\log k \right)  }$ 
```cpp
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> q; // 小根堆
q.push({a[0], 0});
while(k--){
	auto[sum, i] = q.top(); q.pop();
	cout << sum << " "; // 出堆顺序即为答案
	if(i + 1 < n){
		q.push({sum - a[i] + a[i + 1], i + 1}); // 替换
		q.push({sum + a[i + 1], i + 1}); // 加入
	}
}
```

题目：
[acwing 428. 数列](https://www.acwing.com/problem/content/430/) 
[力扣 2386. 找出数组的第 K 大和](https://leetcode.cn/problems/find-the-k-sum-of-an-array/) 

## 字典树 Trie
字典树包含两个操作，插入字符串和查找字符串是否出现或者出现的次数
- 时间复杂度：插入，查找，删除，查前缀数操作都为 ${O\left( |s| \right)  }$, ${|s| }$ 为字符串长度
- 空间复杂度：${O\left( |\Sigma |  \right)  }$，${|\Sigma | }$ 表示字符串总长度

```cpp
const int N, M; // N为所有字符串的总长度, M为字符可能的种类数

struct Trie{
    int son[N][M] = {0}; // son[i][j]表示第i个节点的第j个儿子的编号
    int pass[N] = {0}; // pass[i]表示经过以id为i的节点的单词数量（以其为终点也算经过）
    int end[N] = {0}; // end[i]表示以id为i的节点为结尾的单词数量
    int id = 0; // 记录节点编号，0为树根的编号
    
    void insert(string word){ // 插入单词
        int p = 0;
        for(char &c : word){
            int u = c - 'a';
            if(son[p][u] == 0) son[p][u] = ++id;
            p = son[p][u];
            pass[p]++;
        }
        end[p]++;
    }

    int search(string word){ // 搜索word出现次数
        int p = 0;
        for(char &c : word){
            int u = c - 'a';
            if(son[p][u] == 0) return 0;
            p = son[p][u];
        }
        return end[p];
    }

    void del(string word){ // 删除1个word
        if(search(word) > 0){
            int p = 0;
            for(char &c : word){
                int u = c - 'a';
                p = son[p][u];
                pass[p]--;
            }
            end[p]--;
        }
    }

    int prefix_num(string pre){ // 查询以pre为前缀的单词数量（包含pre本身）
        int p = 0;
        for(char &c : pre){
            int u = c - 'a';
            if(son[p][u] == 0) return 0;
            p = son[p][u];
        }
        return pass[p];
    }
};
```

题目：
[牛客 字典树的实现](https://www.nowcoder.com/practice/7f8a8553ddbf4eaab749ec988726702b) 
[acwing 835. Trie 字符串统计](https://www.acwing.com/problem/content/837/) 
[洛谷 P8306.【模板】字典树](https://www.luogu.com.cn/problem/P8306) （数组很大，需要开成全局数组）
[力扣 212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/) （dfs + 字典树）

01-Trie 树可以查找在二进制下某数是否存在 
[acwing 143. 最大异或对](https://www.acwing.com/problem/content/145/) （在字典树中查找与 x 异或后最大的那个数）
[力扣 421. 数组中两个数的最大异或值](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/) 

## ST 表
ST 表利用倍增思想，是用于解决可重复贡献问题的数据结构，如最大值、最小值、最大公约数、最小公倍数、按位或、按位与等
一般用来解决区间最大值/最小值查询 (RMQ) 问题：有一个数列 ${a_{1} ,a_{2} ,\cdots a_{n}  }$，有 ${m }$ 次查询，每次查询提供左右端点 ${l,r }$，需要快速求出区间 ${\left[ l,r \right]  }$ 的最大值或最小值

- 建表：时间复杂度 ${O\left( n\log n \right)  }$ ，空间复杂度 ${O\left( n\log n \right)  }$ 
状态表示：${f\left[ i,j \right]  }$ 表示以第 ${i }$ 个数为起点，长度为 ${2^{j}  }$ 的区间中的最大值
状态转移：${f\left[ i,j \right] =\max\left( f\left[ i,j-1 \right] ,f\left[ i+2^{j-1},j-1  \right]  \right)  }$ 
初始状态：${f\left[ i,0 \right] =a\left[ i \right]  }$ 
![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202407161030101.png)

注意数组下标从 ${1 }$ 开始存储
```cpp
for(int i = 1; i <= n; i++){ // 初始状态
	f[i][0] = a[i];
}
for(int j = 1; 1 << j <= n; j++){ // 枚举区间长度
	for(int i = 1; i + (1 << j) - 1 <= n; i++){ // 枚举区间起点
		f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
	}
}
```

- 查询：时间复杂度 ${O\left( 1 \right)  }$ 
区间 ${\left[ l,r \right]  }$ 的最大值为 ${\max\left( f\left[ l,k \right] ,f\left[ r-2^{k} +1 ,k\right]  \right)  }$ ，其中 ${k=\log _{2} \left( r-l+1 \right)  }$ 
![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202407161034986.png)


```cpp
int log2[N];
void log2pre(){ // 对数预处理
	log2[1] = 0;
	log2[2] = 1;
	for(int i = 3; i < N; i++){
		log2[i] = log2[i / 2] + 1;
	}
}

int query(int l, int r){ // 查询
	int k = log2[r - l + 1];
	return max(f[l][k], f[r - (1 << k) + 1][k]);
}
```

题目：
[acwing 1274. 奶牛排队](https://www.acwing.com/problem/content/description/1276/) 
[洛谷 P2880 Balanced Lineup G]( https://www.luogu.com.cn/problem/P2880 ) 
[洛谷 P3865 【模板】ST 表](https://www.luogu.com.cn/problem/P3865) （卡常数：需要使用快读，对数预处理，print 输出）


## 树状数组
树状数组是一种支持**单点修改**和**区间查询**的数据结构（树状数组能实现的所有功能都可以被线段树实现，其优势在于代码简单，常数小）
树状数组所维护的信息需要满足两个条件：
1. 结合律：${\left( x \circ y \right) \circ z=x\circ \left( y\circ z \right)  }$ 
2. 可差分：已知 ${x }$ 和 ${x\circ y }$ 可以求出 ${y }$ 

树状数组有两个操作：
1. 在某个位置 ${i }$ 加上一个数 ${x }$ 
2. 求区间 ${\left[ 1,i \right]  }$ 的前缀和

![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202407171445025.png)

- 时间复杂度：
	- 构建：${O\left( n\log n \right)  }$ 或者 ${O\left( n \right)  }$ 
	- 单点修改：${O\left( \log n \right)  }$ 
	- 区域查询：${O\left( \log n \right)  }$ 
- 空间复杂度：${O\left( n \right)  }$ 
```cpp
// 核心操作
int lowbit(int x){
	return x & -x;
}

// O(nlogn)建树
int t[N];
void init(){
	for(int i = 1; i <= n; i++){
		add(i, a[i]);
	}
}

// O(n)建树
void init(){
	for(int i = 1; i <= n; i++){
		t[i] += a[i];
		int j = i + lowbit(i);
		if(j <= n) t[j] += t[i];
	}
}

// 单点修改：第i个数加上x
int add(int i, int x){
	for(; i <= n; i += lowbit(i)){
		t[i] += x;
	}
}

// 区间查询：求区间[1, i]的前缀和
int presum(int i){
	int sum = 0;
	for(; i != 0; i -= lowbit(i)){
		sum += t[i];
	}
	return sum;
}
```

区间修改，单点查询
将树状数组看做差分数组，则其前缀和为修改的量
```cpp
add(l, d);
add(r + 1, -d);

a[x] + presum(x);
```

题目：
[acwing 1264. 动态求连续区间和](https://www.acwing.com/file_system/file/content/whole/index/content/4184199/) 
[acwing 1267. 清点人数](https://www.acwing.com/file_system/file/content/whole/index/content/4184202/) 
[力扣 307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/) 
[acwing 242. 一个简单的整数问题](https://www.acwing.com/problem/content/description/248/) 

### 左边/右边小于当前元素的个数
假设有个桶数组用来记录每个数字出现过几次，遍历每个数字，每遍历到一个就将其对应桶的位置 ${+1 }$ 
边遍历边记录答案，那么比 `nums[i]`小的个数就是：桶数组中 `nums[i]`位置前面的前缀和
对于单点修改，查询前缀和的操作可以使用树状数组来实现桶
- 时间复杂度：${O\left( n\log n \right)  }$ 
```cpp
int ans[n];
for(int i = n; i >= 1; i--){
    ans[i] = presum(nums[i] - 1);
    add(nums[i], 1);
}
```

题目：
[力扣 315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/) （树状数组当做桶）
[洛谷 P5367 【模板】康托展开](https://www.luogu.com.cn/problem/P5367) （康托展开 + 树状数组）


## 排列
### 求下一个排列
步骤：
1. **从后往前**找到第一个 ${a\left[ k \right] <a\left[ k+1 \right]  }$ 的位置 ${k }$ 
2. 若 ${k < 0 }$ 说明数组是有序的，直接翻转即可结束
3. 若 ${k\geq 0 }$，**从后往前**找到第一个 ${a\left[ t \right] >a\left[ k \right]  }$ 的位置 ${t }$ 
4. 交换 ${a\left[ k \right]  }$ 和 ${a\left[ t \right]  }$，交换后可以发现 ${a\left[ k+1\cdots n \right]  }$ 是单调递减的
5. 将 ${a\left[ k+1\cdots n \right]  }$ 翻转

时间复杂度：${O\left( n \right)  }$ 
```cpp
// 该模板支持有重复元素
void nextpermutation(int a[], int n){
	int k = n - 2;
	while(k >= 0 && a[k] >= a[k + 1]) k--;
	if(k >= 0){
		int t = n - 1;
		while(t >= 0 && a[t] <= a[k]) t--;
		swap(a[k], a[t]);
	}
	reverse(a + k + 1, a + n);
}
```

题目：
[洛谷 P1088. 火星人]( https://www.luogu.com.cn/problem/P1088 ) 
[acwing 420. 火星人](https://www.acwing.com/problem/content/422/) 
[力扣 31. 下一个排列](https://leetcode.cn/problems/next-permutation/) 

### STL 排列
- 头文件 `#include<algorithm>` 

`next_permutation` 求下一个排列
- 时间复杂度：${O\left( n \right)  }$ 
如果当前排列是最大的，则下一个排列是最小的（循环结构）
```cpp
// 求数组a的下一个排列
next_permutation(a, a + n);
```

`prev_permutation` 求上一个排列
- 时间复杂度：${O\left( n \right)  }$ 
如果当前排列是最小的，则会返回 `false` 
```cpp
// 求数组a的上一个排列
prev_permutation(a, a + n);
```

题目：
[洛谷 P2525.Uim 的情人节礼物·其之壱](https://www.luogu.com.cn/problem/P2525) 

### 康托展开
求某一排列在所有排列中的排名（从 0 开始）
$$
\Large{ \begin{align} Rank&=\displaystyle{\sum}\limits_{ i = 1 }^{ n } b_{i} \left( n-i \right) ! \\&= b_{1} \left( n-1 \right) !+b_{2} \left( n-2 \right) !+\cdots +b_{i} \left( n-i \right) !+\cdots +b_{n} \cdot 0!\end{align}  }
$$
其中 ${b_{i}  }$ 表示第 ${i }$ 个数右边比该数小的个数

例：排列 ${a }$: ${\{ 3,4,1, 5,2 \}  }$，计算其排列排名
数组   ${b }$：${\{2,2,0,1,0  \}  }$ 
$$
\begin{align} Rank&=2\times 4!+2\times 3!+0\times 2!+1\times 1!+0\times 0!\\&= 61\end{align} 
$$
则该排列为第 ${62 }$ 个
- 时间复杂度：${O\left( n^{2}  \right)  }$ 。可以使用树状数组以 ${O\left( n\log n \right)  }$ 的时间复杂度求得 ${b\left[ i \right]  }$ 数组，这样整体时间复杂度可以降到 ${O\left( n\log n \right)  }$ 
- 空间复杂度：${O\left( n \right)  }$ 
```cpp
// 预处理阶乘
jc[0] = 1;
for(int i = 1; i <= 10; i++){
    jc[i] = i * jc[i - 1];
}

int rank = 0;
for(int i = 1; i <= n; i++){
    // 计算b[i]
    for(int j = i + 1; j <= n; j++)
        if(a[i] > a[j]) b[i]++;
    // 求和
    rank += b[i] * jc[n - i];
}
```


题目：
[洛谷 P2524. Uim 的情人节礼物·其之弐](https://www.luogu.com.cn/problem/P2524) 
[洛谷 P5367 【模板】康托展开](https://www.luogu.com.cn/problem/P5367) （康托展开 + 树状数组）


## 确定有限状态自动机 DFA
状态机是用于描述对象在生命周期内可能的状态以及特定事件触发的状态转移
实现方式是将状态和事件其列成一个二维表格（状态转移表），表示再某一状态下触发某个事件后将会转移到哪个状态
从初始状态开始不断查表转移，最后检测是否到达合法状态

例题：[力扣 65. 有效数字](https://leetcode.cn/problems/valid-number/) 
![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202407201529521.png)


```cpp
enum class State {START, SIGN, INT, DOT, INT_DOT, DEC, E, E_SIGN, E_INT, ERR};
enum class Event {SIGN, NUM, E, DOT, OTHER};
unordered_set<State> endState = {State::INT, State::INT_DOT ,State::DEC, State::E_INT};
State transfer[10][5] = { // 状态转移表
    {State::SIGN, State::INT, State::ERR, State::DOT, State::ERR}, // START
    {State::ERR, State::INT, State::ERR, State::DOT, State::ERR}, // SIGN
    {State::ERR, State::INT, State::E, State::INT_DOT, State::ERR}, // INT
    {State::ERR, State::DEC, State::ERR, State::ERR, State::ERR}, // DOT
    {State::ERR, State::DEC, State::E, State::ERR, State::ERR}, // INT_DOT
    {State::ERR, State::DEC, State::E, State::ERR, State::ERR}, // DEC
    {State::E_SIGN, State::E_INT, State::ERR, State::ERR, State::ERR}, // E
    {State::ERR, State::E_INT, State::ERR, State::ERR, State::ERR}, // E_SIGN
    {State::ERR, State::E_INT, State::ERR, State::ERR, State::ERR}, // E_INT
    {State::ERR, State::ERR, State::ERR, State::ERR, State::ERR}, // ERR
};
Event getEvent(char c){
    if(c == '+' || c == '-') return Event::SIGN;
    else if('0' <= c && c <= '9') return Event::NUM;
    else if(c == 'e' || c == 'E') return Event::E;
    else if(c == '.') return Event::DOT;
    return Event::OTHER;
}

bool isNumber(string s) {
    State state = State::START;
    for(char c : s){ // 状态转移
        state = transfer[(int)state][(int)getEvent(c)];
    }
    if(endState.count(state)){
        return true;
    }
    return false;
}
```



## 环状图（置换群）
一个有向图如果有 ${n }$ 个点，${n }$ 条边，并且每个点的入度和出度都为 ${1 }$，这样的图被称为环状图。环状图一定是由一定数量的环构成的。一个置换群对应一个环状图。
![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202408031319895.png)
当置换一个环内的元素时，该环会产生分裂，导致环的数量 ${+1 }$ 
当置换不同环内的元素时，这两个环会合并，导致环的数量 ${-1 }$ 
- 若一个 ${n }$ 个元素的环状图有 ${k }$ 个环，那么将其通过置换转换为自环图 (环数量为 ${n }$) 最少需要操作 ${n-k }$ 次

题目：
[acwing 1224. 交换瓶子](https://www.acwing.com/problem/content/description/1226/) 
[力扣 765. 情侣牵手](https://leetcode.cn/problems/couples-holding-hands/) （置换群 + 并查集）
[acwing 1553. 用 Swap(0, i) 操作进行排序](https://www.acwing.com/problem/content/description/1555/) 


## 矩阵快速幂
矩阵快速幂用来快速求一个方阵的 ${n }$ 次方，原理与快速幂相同。常用来加速递推
- 递推式为**齐次线性递推式**：
$$
f\left( n \right) =\displaystyle{\sum}\limits_{ i = 1 }^{ m } a_{i} f\left( n-i \right) 
$$
则可以构造矩阵
$$
\begin{bmatrix}
f(n)\\
f(n-1)\\
f(n-2)\\
f(n-3)\\
\vdots \\
f(n-(m-1))
\end{bmatrix}_{m\times 1}
=
\begin{bmatrix}
 a_{1} & a_{2} & a_{3} & \cdots & a_{m-1} & a_{m}\\
 1 & 0 & 0 & \cdots & 0 & 0\\
 0 & 1 & 0 & \cdots & 0 & 0\\
 0 & 0 & 1 & \cdots & 0 & 0\\
 \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
 0 & 0 & 0 & \cdots & 1 & 0
\end{bmatrix}_{m\times m}
\times 
\begin{bmatrix}
f(n-1)\\
f(n-2)\\
f(n-3)\\
f(n-4)\\
\vdots \\
f(n-m)
\end{bmatrix}_{m\times 1}
$$
即
$$
\begin{bmatrix}
f(n)\\
f(n-1)\\
f(n-2)\\
f(n-3)\\
\vdots \\
f(n-(m-1))
\end{bmatrix}_{m\times 1}
=
\begin{bmatrix}
 a_{1} & a_{2} & a_{3} & \cdots & a_{m-1} & a_{m}\\
 1 & 0 & 0 & \cdots & 0 & 0\\
 0 & 1 & 0 & \cdots & 0 & 0\\
 0 & 0 & 1 & \cdots & 0 & 0\\
 \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
 0 & 0 & 0 & \cdots & 1 & 0
\end{bmatrix}_{m\times m}^{n-m}
\times 
\begin{bmatrix}
f(m)\\
f(m-1)\\
\vdots \\
f(3)\\
f(2)\\
f(1)
\end{bmatrix}_{m\times 1}
$$

- 若递推式为**非齐次线性递推式**：
可以将非齐次线性递推转化为其次线性递推 (**并不是所有非齐次线性都可以化成齐次线性**), 如：
$$
f\left( x \right) =\left( 2x-6 \right)c+f\left( x-1 \right) +f\left( x-2 \right) +f\left( x-3 \right)
$$
可以做如下变换
$$
f\left( x \right) +xc=\left[ f\left( x-1 \right) +\left( x-1 \right) c \right] +\left[ f\left( x-2 \right) +\left( x-2 \right) c \right] +\left[ f\left( x-3 \right) +\left( x-3 \right) c \right] 
$$
定义 ${g\left( x \right) =f\left( x \right) +xc }$ 即可将其转换为齐次线性递推
$$
g\left( x \right) =g\left( x-1 \right) +g\left( x-2 \right) +g\left( x-3 \right)
$$


- 时间复杂度： ${O\left( n \right)  }$ 
```cpp
// 矩阵乘法
vector<vector<int>> multiply(vector<vector<int>> &A, vector<vector<int>> &B){
	int n = A.size(), m = A[0].size(), z = B[0].size(); // n*m x m*z = n*z
	vector<vector<int>> C(n, vector<int>(z, 0));
	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			for(int k = 0; k < z; k++){
				C[i][j] += A[i][k] * B[k][j];
			}
		}
	}
	return res;
}

// 矩阵快速幂
vector<vector<int>> matrixPow(vector<vector<int>> A, int n){
	int m = A.size();
	// 定义单位阵
	vector<vector<int>> res(m, vector<int>(m, 0));
	for(int i = 0; i < m; i++) res[i][i] = 1;
	while(n){
		if(n & 1) res = multiply(res, A);
		A = multiply(A, A);
		n >>= 1;
	}
	return res;
}
```

题目：
[力扣 70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/) 


## 位图 bitmap
位图是一种紧凑的哈希集合，用于表示一个固定大小的集合或序列中的元素状态（存在或不存在）。位图通过使用位数组来表示集合中的元素状态，每个元素对应一个位（bit），从而实现高效的空间和时间性能
```cpp
class Bitmap{
    vector<int> data;
public:
    Bitmap(int n){
        data.resize((n + 31) / 32, 0);
    }
    void add(int x){  // 添加元素（将对应位置的值置为1）
        data[x/32] |= 1<<(x%32);
    }
    void remove(int x){  // 删除元素（将对应位置的值置为0）
        data[x/32] &= ~(1<<(x%32));
    }
    bool contains(int x){  // 判断元素是否存在（判断对应位置的值是否为1）
        return data[x/32] & 1<<(x%32);
    }
};
```




# 图论
## 图的存储
### 邻接矩阵
定义
```cpp
g[N][N]; // dist[i][j]存储点i到点j的距离
```
加边
```cpp
// 添加从u到v，长度为w的边：
g[u][v] = w;
```
遍历 ${u }$ 的邻居
```cpp
// 遍历点u所能到达的点v
for(int v = 1; v <= n; v++){
    if(g[u][v] != inf)
        .....
}
```

### 邻接表
定义
```cpp
// 无权边
vector<int> g[N]; // 每个点都存储这个点通向哪
// 有权边
vector<pair<int, int> > g[N]; // {点编号, 距离}
```
加边
```cpp
// 添加从u到v，长度为w的边：
g[u].push_back({v, w});
```
遍历 ${u }$ 的邻居
```cpp
// 遍历点u所能到达的点v：
for(int &[v, w] : g[u]){
	...
}
```

### 链式前向星
定义
```cpp
int id = 1; // 边的id
int head[N], nxt[2 * M + 1], to[2 * M + 1], weight[2 * M + 1]; // 如果是无向边则这三个数组的长度是是边的两倍
```
加边
```cpp
void add_edge(int u, int v, int w){
	nxt[id] = head[u];
	head[u] = id;
	to[id] = v;
	weight[id] = w;
	id++;
}
```
遍历 ${u }$ 的邻居
```cpp
// 遍历点u所能到达的点v：
for(int id = head[u]; id > 0; id = nxt[id]){
	w = weight[id];
	v = to[id];
}
```



## 拓扑排序
求图的拓扑序列，或者判断图中有没有环
- 邻接表存图
流程：
1. 先将所有入度为 $0$ 的点入队
2. 直到队列为空：
	1. 队头出队
	2. 删除以该点出发的所有边
	3. 将删边后入度为 $0$ 的点入队
3. 出队顺序即为拓扑序列
- 时间复杂度：邻接表 ${O\left( n+m \right)  }$，邻接矩阵 $O(n^2)$ ，${n }$ 为点数，${m }$ 为边数
- 如果使用优先队列，则时间复杂度加上 ${O\left( n\log n \right)  }$ 
```cpp
vector <int> g[N]; // 邻接表存图
int in[N]; // 入度,在建图时维护
int ans[N], idx = 0; // 记录拓扑序列

bool topsort(){
    priority_queue <int> q;
    for (int i = 1; i <= n; i++)
        if (!in[i]) q.push(i); // 先将所有入度为0的点加入队列
    while (q.size()){
        int u = q.top();
        q.pop();
        ans[++idx] = u; // 出队顺序即为拓扑序列
        for (auto v : g[u]){
            in[v]--; // 删边
            if (!in[v]) q.push(v);
        }
    }
    return idx == n; // 无环返回1，有环返回0
}
```
 
题目：
[acwing 848. 有向图的拓扑排序](https://www.acwing.com/problem/content/850/) 
[洛谷 U107394 拓扑排序模板](https://www.luogu.com.cn/problem/U107394) 
[力扣 210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 
[力扣 310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/) 
[力扣 LCR 114. 火星词典](https://leetcode.cn/problems/Jf1JuT/) 
[力扣 2192. 有向无环图中一个节点的所有祖先](https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/) 
[洛谷 P4017. 最大食物链计数](https://www.luogu.com.cn/problem/P4017) （拓扑排序 + 动态规划）
[力扣 851. 喧闹和富有](https://leetcode.cn/problems/loud-and-rich/) （拓扑排序 + 动态规划）
[力扣 2050. 并行课程 III](https://leetcode.cn/problems/parallel-courses-iii/) （拓扑排序 + 动态规划）


## 最小生成树
最小瓶颈树：在一张联通的无向图中求一棵生成树，使得树上最大的边权最小
- 最小生成树就是最小瓶颈树（反过来不一定成立）

题目：
[洛谷 P2330【SCOI2005】繁忙的都市](https://www.luogu.com.cn/problem/P2330) 

### Kruskal
依赖于并查集
- 边表存图
流程：
1. 对边进行升序排序
2. 遍历每条边
	1. 如果该条边的两个端点不在一个集合，则选择该边，将两个端点的集合合并

- 时间复杂度：${O\left( m\log m \right)  }$ 主要花费在对边的排序上
- 空间复杂度：${O\left( n+m \right)  }$ 并查集开销以及存边的开销
```cpp
sruct Edge{
	int u, v, w;
};
vector<Edge> edge; // 边表
dsuinit(n); // 并查集初始化

// 将边按权重升序排序
sort(edge.begin(), edge.end(), [](const auto &e1, const auto &e2){
    return e1.w < e2.w;
});
// 遍历每条边
int res = 0, edge_cnt = 0; // 统计权重之和，以及选取的边数
for(auto &e : edge){
    if(merge(e.u, e.v)){ // 并查集合并
        res += e.w;
        edge_cnt++;
    }
}
if(edge_cnt == n - 1) cout << res; // 边数不足n-1条则表示没有最小生成树
else cout << "该图没有最小生成树";
```

题目：
[acwing 859. Kruskal算法求最小生成树](https://www.acwing.com/problem/content/861/) 
[洛谷 P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366) 
[洛谷 P1194 买礼物](https://www.luogu.com.cn/problem/P1194) 

### prim
依赖于堆结构（一般情况下不推荐，推荐使用 Kruskal）
- 邻接表存图
流程：
1. 随机选取一个结点加入集合，并将其连接的所有边加入优先队列
2. 不断在队列中取边，直到队列为空：
	1. 如果这条边连接的顶点不在集合，则选择该边，将该点加入集合，并将其连接的所有边加入优先队列

- 时间复杂度：${O\left( m\log m \right)  }$ 主要花费在堆上
- 空间复杂度：${O\left( n+m \right)  }$ 邻接表，堆，访问记录
```cpp
// 邻接表建图
vector<pair<int, int>> g[N]; // {点编号, 距离}

// 按照w排序的小根堆
struct cmp{
    bool operator()(const pair<int, int> &a, const pair<int, int> &b){
        return a.second > b.second;
    }
};
priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> q;

unordered_set<int> vis; // 记录被访问过的结点

// 初始化：从1号节点开始，将1号结点连接的所有边加入优先队列
vis.insert(1); 
for(auto &edge : g[1]){
    q.push(edge);
}

int res = 0, edge_cnt = 0; // 统计权重之和，以及选取的边数
while(q.size()){
    auto [v, w] = q.top(); q.pop();
    if(!vis.count(v)){
        vis.insert(v);
        res += w;
        edge_cnt++;
        for(auto &edge : g[v]){
            q.push(edge);
        }
    }
}

if(edge_cnt == n - 1) cout << res; // 边数不足n-1条则表示没有最小生成树
else cout << "该图没有最小生成树";
```

题目：
[acwing 858. Prim算法求最小生成树](https://www.acwing.com/problem/content/860/) 


## 最短路径
![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202502221341835.png)

### Dijkstra
求单源最短路径
- **要求图中不含负权边** 
#### 朴素版 Dijkstra
用于稠密图
- 邻接矩阵存图
流程：
1. 初始化 $dis$ 数组
2. 循环 $n$ 次：
	1. 将集合外最短距离的点加入集合（可以堆优化）
	2. 从该点出发更新所有其他集合外的点的距离
- 时间复杂度：${O\left( n^{2}  \right)  }$，${n }$ 为点数，${m }$ 为边数
```cpp
// 朴素版dijkstra
int g[N][N]; // 邻接矩阵存图
memset(g, 0x3f, sizeof mp);
int dis[N]; // 点1到其他点的最短距离
bool vis[N]; // 表示点是否在集合内

void dijkstra(){
    //1.初始化dis数组
    memset(dis, 0x3f, sizeof dis);
    dis[1] = 0;
    //2.循环n次
    for (int i = 1; i <= n; i++){
        //(1).找到集合外距离最小的点加入集合
        int u = -1;
        for (int j = 1; j <= n; j++)
            if (!vis[j] && (u == -1 || dis[j] < dis[u]))
                u = j;
        vis[u] = 1;
        //(2).以该点出发更新集合外所有点的距离
        for (int v = 1; v <= n; v++)
            if (!vis[v])
                dis[v] = min(dis[v], dis[u] + g[u][v]);
    }
}
```

#### 堆优化版 Dijkstra
用于稀疏图 (${n\approx m }$)
- 邻接表存图
流程：
1. 初始化 $dis$ 数组和堆
2. 循环直到堆为空：
	1. 不断弹出堆顶，直到找到未被加入集合的点，将其加入集合
	2. 从该点出发更新所有其他集合外的点的距离，更新后将新边入堆
- 时间复杂度：${O\left(m\log m \right)  }$，${n }$ 为点数，${m }$ 为边数
```cpp
// 堆优化dijkstra
vector <PII> g[N]; // 邻接表存储 {点编号, 距离}
int dis[N]; // 起点到每个点的距离
bool vis[N]; // 表示点是否在集合内

void dijkstra(){
    //1.初始化dis数组,初始化堆
    memset(dis, 0x3f, sizeof dis);
    priority_queue <PII, vector<PII>, greater<PII> > q; // {距离， 点编号}
    dis[1] = 0;
    q.push({ 0,1 });
    //2.循环只要堆不为空
    while(q.size()){
	    //(1).找到集合外距离最小的点加入集合
        int u = q.top().second;
        q.pop();
        if (vis[u]) continue;//如果该点已被更新过了，找下一点
        vis[u] = true;
        //(2).以该点出发更新集合外所有点的距离
        for (auto[w, v] : g[u]){
            if(dis[v] > dis[u] + w){
	            dis[v] = dis[u] + w;
	            q.push({ dis[v],v });//更新过后就入堆
            }
        }
    }
}
```

题目：
[acwing 849. Dijkstra 求最短路 I](https://www.acwing.com/problem/content/851/) 
[acwing 850. Dijkstra 求最短路 II](https://www.acwing.com/problem/content/852/) 
[洛谷 P4779【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779) 
[力扣 2642. 设计可以求最短路径的图类](https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/)
[力扣 743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/) 
[力扣 1976. 到达目的地的方案数](https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/) （dijkstra + dp）

[力扣 1631. 最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/) （特殊距离度量）
[力扣 778. 水位上升的泳池中游泳](https://leetcode.cn/problems/swim-in-rising-water/) （特殊距离度量）

#### 0-1BFS（0-1 边权最短路）
当一个图中的边权只有 0 和 1 两种情况时需要求最短路，可以使用**双堆队列**优化的 dijkstra 算法。
由于边权只有 0 和 1，因此可以将 dijkstra 算法中的优先队列改为使用双端队列，每次将边入队时，如果边权为 0 则将边从队头插入，如果边权为 1 则将边从队尾插入，这样相当于使用更少的复杂度完成了队列中排序的功能。

题目：
[力扣 2290. 到达角落需要移除障碍物的最小数目](https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/) 
[力扣 1368. 使网格图至少有一条有效路径的最小代价](https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/) 


### Bellman-Ford
求有负权边的单源最短路（不建议使用 bellman-ford，spfa 完全优于 bellman-ford）
- 图中可以存在负权边
- 边表存图
流程：
1. 遍历每条边进行松弛操作，重复该步骤直到 dis 数组不再发生变化（最多执行 n - 1 次）
- 时间复杂度：${O\left( nm \right)  }$ ，${n }$ 为点数，${m }$ 为边数
```cpp
struct Edge{
	int u, v, w;
};
vector<Edge> e(m); // 边表
vector<int> dis(n, inf); // 距离数组

void bellman_ford(){
	dis[start] = 0;
	bool change = true; // 记录dis数组有没有被改变
	
	while(change){ // 最多执行n - 1次
		change = false;
		for(auto &[u, v, w] : e){
			if(dis[u] + w < dis[v]){ // 松弛操作
				dis[v] = dis[u] + w;
				change = true;
			}
		}
	}
}

void bellman_ford(){ // 简便版
	dis[start] = 0;
	for(int i = 0; i < n - 1; i++){
		for(auto &[u, v, w] : e){
			dis[v] = min(dis[v], dis[u] + w); // 松弛操作
		}
	}
}

```

#### 有边数限制的单源最短路径
求从源点到目标点的最多经过 ${k }$ 条边的最短距离
- 图可以存在负权边
- 边表存图
流程：
1. 循环 ${k }$ 次（表示每条路径的边数不超过 ${k }$），
2. 将上一轮的 ${dis }$ 数组进行备份
3. 遍历每条边进行松弛操作：${dis\left[ v \right] =\min\{ dis\left[ v \right] ,backup\left[ u \right] +w \}  }$ 
- 时间复杂度：${O\left( nm \right)  }$，${n }$ 为点数，${m }$ 为边数
```cpp
struct Edge{
	int u, v, w;
};
vector<Edge> e(m); // 边表
vector<int> dis(n, inf); // 距离数组

for(int i = 0; i < k; i++){
    vecotr<int> backup = dis; // 备份，只使用上一次的值来更新
    for(auto &[u, v, w] : e){
	    dis[v] = min(dis[v], backup[u] + w); // 松弛操作
    }
}
```

题目：
[acwing 853. 有边数限制的最短路](https://www.acwing.com/problem/content/855/) 
[力扣 787. K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/) 

#### 判断有无负环
（依旧推荐使用 spfa）
从 A 出发，不断进行松弛操作，如果松弛操作到达第 ${n }$ 轮依然存在，则说明从 A 出发能够到达一个负环
判断全图有无负环：添加一个超级源点，从超级源点出发即可

### spfa
求有负权边的单源最短路
- 图中可以存在负权边
- 邻接表存图
- 时间复杂度：一般 ${O\left( m \right)  }$，最坏 ${O\left( nm \right)  }$，${n }$ 为点数，${m }$ 为边数
```cpp
vector<PII> g[N]; // 邻接表存储 {点编号，距离}
int dis[N]; // 起点到每个点的距离
bool vis[N]; // 记录队列中是否已存在i
queue<int> q;

void spfa(){
    //1.初始化dis数组，初始化队列
    memset(dis, 0x3f, sizeof dis);
    dis[1] = 0;
    q.push(1);
    vis[1] = true;
    
    while(q.size()){
        int u = q.front(); q.pop();
        vis[u] = false;
        for(auto &[v, w] : g[u]){
            if(dis[v] > dis[u] + w){
                dis[v] = dis[u] + w;
                if(!vis[v]){ // 如果队列中已存在v, 则不需要将v重复插入队列
                    q.push(v);
                    vis[v] = true;
                }
            }
        }
    }
}
```

题目：
[acwing 851. spfa 求最短路](https://www.acwing.com/problem/content/853/) 


#### 判断有无负环
添加一个数组，记录每个点被松弛的次数（入队的次数），如果某个点入队的次数 ${>n-1 }$ 时则说明从源点出发能够到达一个负环
判断全图有无负环：添加一个超级源点，从超级源点出发即可
```cpp
bool spfa(int n){
    // 从1点出发判断有无负环
    dis[1] = 0;
    relax_cnt[1]++; // 每个点被松弛的次数
    q.push(1);
    vis[1] = true;
    
    while(q.size()){
        int u = q.front(); q.pop();
        vis[u] = false;
        for(auto &[v, w] : g[u]){
            if(dis[u] + w < dis[v]){
                dis[v] = dis[u] + w;
                if(!vis[v]){
                    if(++relax_cnt[v] > n - 1){ // 某个结点松弛次数超过n-1次
                        return true;
                    }
                    q.push(v);
                    vis[v] = true;
                }
            }
        }
    }
    return false;
}
```

题目：
[洛谷 P3385【模板】负环](https://www.luogu.com.cn/problem/P3385) 


### floyd
求多源最短路
- 邻接矩阵存图
- 时间复杂度：${O\left( n^{3}  \right)  }$ ，${n }$ 为点数，${m }$ 为边数
```cpp
for (int k = 1; k <= n; k++) 
	for (int i = 1; i <= n; i++) 
		for (int j = 1; j <= n; j++) 
            g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
```

[acwing 854. Floyd 求最短路](https://www.acwing.com/problem/content/856/) 
[洛谷 P2910【USACO08OPEN】Clear And Present Danger S](https://www.luogu.com.cn/problem/P2910) 


### A_star
求源点到目标点的最短距离
相当于堆优化 dijkstra 的改进，只修改了堆中用于排序的依据，剩下所有细节和 dijkstra 一致。只优化了常数时间，时间复杂度没有变化
堆中根据**从源点出发到达当前点的距离**+**当前点到终点的预估距离**来进行排序
- 预估函数要求：当前点到终点的预估距离 ${\leq  }$ 当前点到终点的真实最短距离
- 预估距离越接近真实最短距离，效率越快
预估函数通常有：
- 曼哈顿距离
```cpp
int h(int x1, int y1, int x2, int y2){
	return abs(x1 - x2) + abs(y1 - y2);
}
```
- 对角线距离
```cpp
int h(int x1, int y1, int x2, int y2){
	return max(abs(x1 - x2), abs(y1 - y2));
}
```
- 欧氏距离
```cpp
int h(int x1, int y1, int x2, int y2){
	return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}
```

- 时间复杂度：${O\left(m\log m \right)  }$，${n }$ 为点数，${m }$ 为边数
```cpp
// A*
int h(int s, int e){
	// 返回从s点到e点的估计距离
}

vector <PII> g[N]; // 邻接表存储 {点编号, 距离}
int dis[N]; // 起点到每个点的距离
bool vis[N]; // 表示点是否在集合内

void dijkstra(){
    //1.初始化dis数组,初始化堆
    memset(dis, 0x3f, sizeof dis);
    priority_queue <PII, vector<PII>, greater<PII> > q; // {代价， 点编号}
    dis[1] = 0;
    q.push({ 0 + h(1, n),1 }); // 到达当前点的距离 + 当前点到终点的预估距离
    //2.循环只要堆不为空
    while(q.size()){
	    //(1).找到集合外距离最小的点加入集合
        int u = q.top().second;
        q.pop();
        if (vis[u]) continue;//如果该点已被更新过了，找下一点
        vis[u] = true;
        //(2).以该点出发更新集合外所有点的距离
        for (auto[w, v] : g[u]){
            if(dis[v] > dis[u] + w){
	            dis[v] = dis[u] + w;
	            q.push({ dis[v] + h(v, n), v }); // 到达当前点的距离 + 当前点到终点的预估距离
            }
        }
    }
}
```


## 分层图最短路
对结点的状态进行扩展，即可以理解为有多个平行的图

题目：
[力扣 864. 获取所有钥匙的最短路径](https://leetcode.cn/problems/shortest-path-to-get-all-keys/) 
[洛谷 P4568【JLOI2011】飞行路线](https://www.luogu.com.cn/problem/P4568) 

# 动态规划 DP
## 记忆化搜索
当知道动态规划的递推式，但是又**难以分析出更新顺序时**可以使用递归实现动态规划过程，在递归时通过记忆数组标记状态是否出现过从而避免重复的计算
```cpp
void dfs(状态){
	if(mem[状态]已记录) return mem[状态];
	...
	递归计算res
	...
	return mem[状态] = res;
}
```


题目：
[洛谷 P1464. Function](https://www.luogu.com.cn/problem/P1464) 
[力扣 2312. 卖木头块](https://leetcode.cn/problems/selling-pieces-of-wood/) 


## 背包问题
![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202402192341740.png)

### 01 背包
有 $n$ 件物品, 第 $i$ 件物品的重量为 $w[i]$，价值为 $v[i]$ ，背包最大容量为 $T$ ，求背包最多能装的价值
==每个物品最多只能选一个== 
- 状态表示：
${dp\left[ i,j \right]  }$ 表示只从前 ${i }$ 个物品中选，总重量不超过 ${j }$ 的情况下能获得的最大价值
- 目标答案：
${dp\left[ n,T \right]  }$ 
- 初始状态：
${dp\left[ 0,0 \right] =0 }$ 
- 状态转移：
$$
dp\left[ i,j \right] =\begin{cases} \max\{dp\left[ i-1,j \right],\quad dp\left[ i-1,j-w\left[ i \right]  \right] +v\left[ i \right]  \} &,j-w\left[ i \right] \geq 0\\dp\left[ i-1,j \right] &,j-w\left[ i \right] <0 \end{cases} 
$$
- 时间复杂度：${O\left( nT \right)  }$ 
- 空间复杂度：${O\left( nT \right)  }$ 
```cpp
for(int i = 1; i <= n; i++){
	for(int j = 0; j <= T; j++){
		if(j - w[i] >= 0)
			dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
		else dp[i][j] = dp[i - 1][j];
	}
}
```

- 空间优化
可以优化第一维空间
$$
dp\left[ j \right] =\max\{ dp\left[ j \right],\quad dp\left[ j-w\left[ i \right]  \right] +v\left[ i \right]   \} 
$$
**注意降维后背包容量要逆序遍历**！
- 时间复杂度：$O(nT)$ 
- 空间复杂度：${O\left( T \right)  }$ 
```cpp
for(int i = 1; i <= n; i++) // 依次枚举每个物品
    for(int j = T; j >= w[i]; j--) // 背包容量从右往左更新
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
```

题目：
[acwing 2. 01 背包问题](https://www.acwing.com/problem/content/2/) 
[洛谷 P1048. 采药]( https://www.luogu.com.cn/problem/P1048 ) 
[洛谷 P1049. 装箱问题]( https://www.luogu.com.cn/problem/P1049 ) 
[洛谷 P1060. 开心的金明]( https://www.luogu.com.cn/problem/P1060 ) 
[acwing 426. 开心的金明](https://www.acwing.com/problem/content/428/) 
[洛谷 P2430. 严酷的训练](https://www.luogu.com.cn/problem/P2430) 

### 完全背包
有 $n$ 件物品, 第 $i$ 件物品的重量为 $w[i]$，价值为 $v[i]$ ，背包最大容量为 $T$ ，求背包最多能装的价值
==每个物品有无限件可用== 
- 状态表示：
${dp\left[ i,j \right]  }$ 表示只从前 ${i }$ 个物品中选，总重量不超过 ${j }$ 的情况下能获得的最大价值
- 目标答案：
${dp\left[ n,T \right]  }$ 
- 初始状态：
${dp\left[ 0,0 \right] =0 }$ 
- 状态转移：
$$
\begin{align} dp\left[ i,j \right] =\max\{&dp\left[ i-1,j \right],\\&dp\left[ i-1,j-w\left[ i \right]  \right] +v\left[ i \right] ,\\&dp\left[ i-1,j-w\left[ i \right] \times 2 \right] +v\left[ i \right] \times 2,\\&\cdots ,\\&dp\left[ i-1,j-w\left[ i \right] \times k \right] +v\left[ i \right] \times k \} \\&其中k为满足j-w\left[ i \right] \times k\geq 0最大的k \end{align} 
$$

- 时间复杂度：${O\left( nT^{2}  \right)  }$ 
- 空间复杂度：${O\left( nT \right)  }$ 
```cpp
int dp[N][T];
for (int i = 1; i <= n; i++){
	for (int j = 0; j <= T; j++){
		for(int k = 0; j - w[i] * k >= 0; k++){
			dp[i][j] = max(dp[i][j], dp[i - 1][j - w[i] * k] + v[i] * k);
		}
	}
}
```

- 时间优化
可以使用状态转移式得到 ${dp\left[ i,j-w\left[ i \right]  \right]  }$ 的状态转移式（即用 ${j-w\left[ i \right]  }$ 替换 ${j }$）
$$
\begin{align} dp\left[ i,j-w\left[ i \right]  \right] =\max\{&dp\left[ i-1,j-w\left[ i \right]  \right],\\&dp\left[ i-1,j-w\left[ i \right]\times 2  \right] +v\left[ i \right] ,\\&dp\left[ i-1,j-w\left[ i \right] \times 3 \right] +v\left[ i \right] \times 2,\\&\cdots ,\\&dp\left[ i-1,j-w\left[ i \right] \times k \right] +v\left[ i \right] \times \left( k-1 \right)  \} \\&其中k为满足j-w\left[ i \right] \times k\geq 0最大的k \end{align} 
$$
注意最后一行不是 ${dp\left[ i-1,j-w\left[ i \right] \times \left( k+1 \right)  \right] +v\left[ i \right] \times k  }$ ，因为 ${j-w\left[ i \right] \times \left( k+1 \right)  <0}$ 不是合法状态
再将该式加上 ${v\left[ i \right]  }$ ，结果为
$$
\begin{align} dp\left[ i,j-w\left[ i \right]  \right] +v\left[ i \right] =\max\{&dp\left[ i-1,j-w\left[ i \right]  \right]+v\left[ i \right] ,\\&dp\left[ i-1,j-w\left[ i \right]\times 2  \right] +v\left[ i \right]\times 2 ,\\&dp\left[ i-1,j-w\left[ i \right] \times 3 \right] +v\left[ i \right] \times 3,\\&\cdots ,\\&dp\left[ i-1,j-w\left[ i \right] \times k \right] +v\left[ i \right] \times k  \} \\&其中k为满足j-w\left[ i \right] \times k\geq 0最大的k \end{align} 
$$
可以发现该式右边为最原始的状态转移方程中除了第一项剩余的部分，因此可以将该项代入原始转移方程中得到化简后的转移方程
$$
dp\left[ i,j \right] =\begin{cases} \max\{ dp\left[ i-1,j \right] ,dp\left[ i,j-w\left[ i \right]  \right] +v\left[ i \right]  \} &,j-w\left[ i \right] \geq 0\\dp\left[ i-1,j \right] &,j-w\left[ i \right] <0 \end{cases} 
$$
- 时间复杂度：${O\left( nT \right)  }$ 
- 空间复杂度：${O\left( nT \right)  }$ 
```cpp
for (int i = 1; i <= n; i++){
	for (int j = 0; j <= T; j++){
		if(j - w[i] >= 0)
			dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i]);
		else dp[i][j] = dp[i - 1][j];
	}
}
```


- 空间优化
可以优化掉第一维空间
$$
dp\left[ i \right] =\max\{ dp\left[ j \right],\quad dp\left[ j-w\left[ i \right]  \right] +v\left[ i \right]   \} 
$$
- 时间复杂度：$O(nT)$ 
- 空间复杂度：${O\left( T \right)  }$ 
```cpp
for (int i = 1; i <= n; i++){ // 依次枚举每个物品
	for (int j = w[i]; j <= T; j++){ // 背包容量从左往右更新
		dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
	}
}
```


题目：
[acwing 3. 完全背包问题](https://www.acwing.com/problem/content/3/) 
[力扣 322. 零钱兑换](https://leetcode.cn/problems/coin-change/) 

### 多重背包
有 $n$ 件物品, 第 $i$ 件物品的重量为 $w[i]$，价值为 $v[i]$ ，背包最大容量为 $T$ ，求背包最多能装的价值
==每个物品最多拿 ${s\left[ i \right]  }$ 个== 

- 状态表示
${dp\left[ i,j \right]  }$ 表示只从前 ${i }$ 个物品中选，总重量不超过 ${j }$ 的情况下能获得的最大价值

- 目标答案
${dp\left[ n,T \right]  }$ 

- 初始状态
${dp\left[ 0,0 \right] =0 }$ 

- 状态转移
$$
\begin{align} dp\left[ i,j \right] =\max\{&dp\left[ i-1,j \right],\\&dp\left[ i-1,j-w\left[ i \right]  \right] +v\left[ i \right] ,\\&dp\left[ i-1,j-w\left[ i \right] \times 2 \right] +v\left[ i \right] \times 2,\\&\cdots ,\\&dp\left[ i-1,j-w\left[ i \right] \times k \right] +v\left[ i \right] \times k \} \\&其中j-w\left[ i \right] \times k\geq 0且k\leq s\left[ i \right]  \end{align} 
$$
- 时间复杂度：${O\left( nTs \right)  }$ 
- 空间复杂度：${O\left( nT \right)  }$ 
```cpp
for(int i = 1; i <= n; i++){ // 依次枚举每个物品
	for(int j = 0; j <= T; j++){ // 依次枚举背包容量
		for(int k = 0; k <= s[i] && j - w[i] * k >= 0; k++){ // 第i个物品选k件
			dp[i][j] = max(dp[i][j], dp[i - 1][j - w[i] * k] + v[i] * k);
		}
	}
}
```

- 空间优化
可以优化掉第一维空间
$$
\begin{align} dp\left[ j \right] =\max\{&dp\left[ j \right],\\&dp\left[ j-w\left[ i \right]  \right] +v\left[ i \right] ,\\&dp\left[ j-w\left[ i \right] \times 2 \right] +v\left[ i \right] \times 2,\\&\cdots ,\\&dp\left[ j-w\left[ i \right] \times k \right] +v\left[ i \right] \times k \} \\&其中j-w\left[ i \right] \times k\geq 0且k\leq s\left[ i \right]  \end{align} 
$$
**注意降维后背包容量要逆序遍历**！
- 时间复杂度：${O\left( nTs \right)  }$ 
- 空间复杂度：${O\left( T \right)  }$ 
```cpp
for(int i = 1; i <= n; i++){ // 依次枚举每个物品
	for(int j = T; j >= 0; j--){ // 容量从右往左更新
		for(int k = 0; k <= s[i] && j - w[i] * k >= 0; k++){ // 第i个物品选k件
			dp[j] = max(dp[j], dp[j - w[i] * k] + v[i] * k);
		}
	}
}
```

- 时间优化（二进制优化）
主要思路是将物品以二进制的方式进行拆分，比如某样物品的个数为 ${19 }$ 个，则可用拆成以下 ${5 }$ 组，每组有 ${1,2,4,8,4 }$ 个物品。拆分后转化为 0-1 背包问题
- 时间复杂度：${O\left( nT\log s \right)  }$ 
- 空间复杂度：${O\left( n\log s+T \right)  }$ 
```cpp
int n, T, cnt = 0;
int w[N * 12], v[N * 12]; // 数组大小为NlogS
int dp[2010];

for(int i = 1; i <= n; i++){
	int a, b, s;
	cin >> a >> b >> s; // 重量，价值，数量
	// 对该物品进行二进制拆分，每j个拆分出一个新的物品
	for(int j = 1; j <= s; j <<= 1){
		cnt++;
		w[cnt] = a * j;
		v[cnt] = b * j;
		s -= j;
	}
	if(s > 0){
		cnt++;
		w[cnt] = a * s;
		v[cnt] = b * s;
	}
}
// 01背包模板
for(int i = 1; i <= cnt; i++){
	for(int j = T; j >= w[i]; j--){
		dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
	}
}
```

题目：
[acwing 4. 多重背包问题 I](https://www.acwing.com/problem/content/4/) 
[acwing 5. 多重背包问题 II](https://www.acwing.com/problem/content/5/) 

### 二维费用背包
有 $n$ 件物品, 第 $i$ 件物品的重量为 $w[i]$，体积为 ${m\left[ i \right]  }$，价值为 $v[i]$ ，背包最大承受重量为 $T$ ，最大承受体积为 ${M }$， 求背包最多能装的价值
==每个物品最多只能选一个== 

- 状态表示：$dp[j,k]$ 表示背包承受重量为 $j$ ，承受体积为 ${k }$ 时背包最多能装下的最大价值
- 初始状态：${dp\left[ 0,k \right] =0,dp\left[ j,0 \right] =0, \quad j=1\cdots T,k=1\cdots M }$ 
- 动态转移：${dp\left[ j,k \right] =max\left( dp\left[ j,k \right] ,dp\left[ j-w\left[ i \right] ,k-m\left[ i \right]  \right] +v\left[ i \right]  \right)  }$ 
- 时间复杂度：$O(nTM)$ 
```cpp
for(int i = 1; i <= n; i++){ // 枚举物品
    for(int j = T; j >= w[i]; j--){ // 枚举重量，从后往前
        for(int k = M; k >= m[i]; k--){ // 枚举体积，从后往前
            dp[j][k] = max(dp[j][k], dp[j - w[i]][k - m[i]] + v[i]);
```

题目：
[acwing 8. 二维费用的背包问题](https://www.acwing.com/problem/content/8/) 
[洛谷 P1507. NASA的食物计划](https://www.luogu.com.cn/problem/P1507) 

### 分组背包
有 $n$ 组物品, 第 $i$ 组中有 ${s\left[ i \right]  }$ 个物品，每个物品重量分别为 $w[i,j]$，价值为 $v[i,j]$ ，背包最大容量为 $T$ ，求背包最多能装的价值
==每组中最多拿 ${1 }$ 个物品== 

- 状态表示：$dp[j]$ 表示背包容量为 $j$ 时背包最多能装下的最大价值
- 初始状态：${dp\left[ 0 \right] =0 }$ 
- 动态转移：$dp[j]=max(dp[j],dp[j-w[i,k]]+v[i,k])$ 
- 时间复杂度：$O(nTs)$ 
```cpp
for(int i = 1; i <= n; i++) // 枚举组
    for(int j = T; j >= 0; j--) // 枚举重量，从右往左
        for(int k = 0; k < s[i]; k++) // 枚举组中的物品
            if(j >= w[i][k]) // 能选择则更新
                dp[j] = max(dp[j], dp[j - w[i][k]] + v[i][k]);
```

题目：
[acwing 9. 分组背包问题](https://www.acwing.com/problem/content/9/) 



## 线性 DP
线性 dp 最常用的状态表示方式是，以第 ${i }$ 个元素为结尾的前缀序列的答案数

[力扣 2369. 检查数组是否存在有效划分](https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/) 
[力扣 121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/) （线性 DP / 贪心 / 双指针）


### 最长上升子序列 (LIS)
求序列 $a_1,a_2,a_3 \dots a_n$ 中最长的单调上升的子序列的长度

- 状态表示：$f[i]$ 表示以第 ${i }$ 个数结尾的最长上升子序列长度的最大值
- 初始状态：$f[i] = 1\quad ,(i=1\sim n)$ 
- 状态转移：$f[i] = max(f[i],f[j]+1)\quad j = 1,2,3..i-1且a[j]<a[i]$ 
- 时间复杂度：${O\left( n^{2}  \right)  }$ 
```cpp
for (int i = 1; i <= n; i++) {
	f[i] = 1;
	for (int j = 1; j < i; j++)
		if (a[j] < a[i]) // 改为<=则是求最长不降子序列长度
			f[i] = max(f[i], f[j] + 1);
}
// 答案是max(f[1],f[2], ... ,f[n])
```


- 状态表示：$f[i]$ 表示长度为 $i$ 的上升序列的最小结尾
方法：循环遍历 $a[i]$,对于每个数字，在 ${f }$ 数组中找到第一个 ${\geq a\left[ i \right]  }$ 的位置（使用二分查找），并将其替换为 ${a\left[ i \right]  }$。最终 ${f }$ 数组的长度即为答案
严格上升：${\geq  }$ 
非严格上升：${> }$ 
严格下降：${\leq  }$ 
非严格下降：${< }$ 
- 时间复杂度：${O\left( n\log n \right)  }$ 
```cpp
// 手写二分
vector<int> f;
for(int i = 0; i < n; i++){
	// 在f中找到第一个>= a[i]的位置
	int l = 0, r = f.size() - 1;
	while(l < r){
		int mid = l + r >> 1;
		if(f[mid] >= a[i]) r = mid;
		else l = mid + 1;
	}
	if(f[l] >= a[i]) f[l] = a[i];
	else f.push_back(a[i]);
} // 答案是f.size();
```


题目：
[力扣 300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/) 
[acwing 895. 最长上升子序列](https://www.acwing.com/problem/content/897/) 
[acwing 896. 最长上升子序列 II](https://www.acwing.com/problem/content/898/) 
[acwing 482. 合唱队形](https://www.acwing.com/problem/content/description/484/) 

#### dilworth 定理
7. 用最长不上升序列覆盖整个序列，所需要的最少个数，等于最长上升序列长度
8. 用最长上升序列覆盖整个序列，所需要的最少个数，等于最长不上升序列长度
如：1, 7, 8, 2, 3, 4
最长上升序列覆盖整个序列的最小个数：2，即 (1, 2, 3, 4)(7, 8)
最长不上升序列长度：2，如 (7, 2)

题目：
[洛谷 P1020. 导弹拦截]( https://www.luogu.com.cn/problem/P1020 ) 

### 最长公共子序列 (LCS)
求序列 $a_1,a_2,a_3\dots a_n$ 与序列 $b_1,b_2,b_3\dots b_m$ 最长的相同的子序列长度

- 状态表示：$f[i,j]$ 表示 $a[1\sim i]$ 与 $b[1 \sim j]$ 的公共序列长度的最大值
- 初始状态：$f[i,0] = 0,f[0,j] = 0,f[0,0] = 0 \quad (i=1 \sim n, j=1 \sim m)$ 
- 状态转移：$f[i,j] = \begin{cases} f[i-1,j-1]+1 & a[i]=b[j] \\ max(f[i-1,j],f[i,j-1]) & a[i] \ne b[j] \end{cases}$ 
- 时间复杂度：$O(nm)$ 
```cpp
for(int i = 1;i<=n;i++)
	for (int j = 1; j <= m; j++) 
		if (a[i] == b[j]) f[i][j] = f[i - 1][j - 1] + 1;
		else f[i][j] = max(f[i - 1][j], f[i][j - 1]);
//f[n][m]是答案
```

题目：
[acwing 897. 最长公共子序列](https://www.acwing.com/problem/content/899/) 

### 最大连续子段和
给出一个序列 ${a_{1} ,a_{2} ,\cdots ,a_{n}  }$，选出其中连续的一段使得这段和最大

- 状态表示：$f[i]$ 表示以 $a[i]$ 结尾的最大子段和
- 初始状态：$f[1] = a[1]$ 
- 状态转移：$f[i] = max(f[i-1]+a[i],a[i])$ 
- 时间复杂度：$O(n)$ 
```cpp
for (int i = 1; i <= n; i++)
	f[i] = max(f[i - 1] + a[i], a[i]);
// 答案是max(f[1],f[2], ... ,f[n])
```

题目：
[洛谷 P1115. 最大子段和](https://www.luogu.com.cn/problem/P1115) 
[acwing 55. 连续子数组的最大和](https://www.acwing.com/file_system/file/content/whole/index/content/3600/) 

### 最大子矩阵和（二维最大连续子段和）
给出一个矩阵，求一个子矩阵使得其元素的和最大，求这个最大的和
将二维转换为一维最大连续子段和问题
- 时间复杂度：${O\left( n^{2}m  \right)  }$ 
![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202403081603663.png)
```cpp
// 预处理列的前缀和
for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
	        colPresum[i][j] = colPresum[i - 1][j] + mp[i][j];

for(int i = 1; i <= n; i++){ // 枚举上边界
	for(int j = i; j <= n; j++){ // 枚举下边界
		// 左右边界求最大子段和
		dp[1] = 0;
		for(int k = 1; k <= m; k++){
			dp[k] = max(dp[k - 1], 0) + colPresum[j][k] - colPresun[i - 1][k];
			ans = max(ans, dp[k]); // 记录答案
		}
	}
}
```

题目：
[洛谷 P1719. 最大加权矩形](https://www.luogu.com.cn/problem/P1719) 
[acwing 126. 最大的和](https://www.acwing.com/problem/content/description/128/) 
[力扣 面试题 17.24. 最大子矩阵](https://leetcode.cn/problems/max-submatrix-lcci/) 


### 最短编辑距离
$a,b$ 是两个字符串，求将 ${a }$ 转换为 ${b }$ 所需要的最少的操作次数
操作有：
1. 删除一个字符	
2. 插入一个字符	
3. 将一个字符改为另外一个字符

- 状态表示：$f[i,j]$ 表示将 $a[1 \sim i]$ 变成 $b[1\sim j]$ 的操作方式次数的最小值
- 初始状态：$f[i,0] = i,f[0,j] = j \quad ,(i=1\sim n,j = 1\sim m)$ 
- 状态转移：$f[i,j] = \begin{cases} f[i-1,j-1] & a[i]=b[j] \\ min(f[i-1,j-1],f[i,j-1],f[i-1,j])+1 & a[i] \ne b[j] \end{cases}$ 
- 时间复杂度：$O(nm)$ 
```cpp
for (int i = 1; i <= n; i++)f[i][0] = i;
for (int j = 1; j <= m; j++)f[0][j] = j;

for (int i = 1; i <= n; i++)
	for (int j = 1; j <= m; j++)
		if (a[i] == b[j])f[i][j] = f[i - 1][j - 1];
		else f[i][j] = min(f[i - 1][j - 1], min(f[i - 1][j], f[i][j - 1])) + 1;
//f[n][m]是答案
```

题目：
[acwing 902. 最短编辑距离](https://www.acwing.com/problem/content/904/) 
[力扣 72. 编辑距离](https://leetcode.cn/problems/edit-distance/) 
[acwing 899. 编辑距离](https://www.acwing.com/problem/content/901/) 

## 路径 DP （有向无环图 DP）
从一个起点出发，按照一定规则向前移动（无法回头）直到终点，求最终的线路个数或者取得值的最值
特点是某一位置的值只与能到达该位置的上一位置有关，而与如何到达上一位置无关

```cpp
for(i = 初始位置 -> 最终位置){
    dp[i] = f(dp[所有能到i的位置j]); // 要确保dp[j]已经被计算过
}
```

题目：
[acwing 898. 数字三角形](https://www.acwing.com/problem/content/900/) 
[洛谷 P1216. 数字三角形](https://www.luogu.com.cn/problem/P1216) 
[力扣 120. 三角形最小路径和](https://leetcode.cn/problems/triangle/) 
[acwing 1015. 摘花生](https://www.acwing.com/problem/content/description/1017/) 
[洛谷 P1255. 数楼梯](https://www.luogu.com.cn/problem/P1255) （dp+高精度）
[洛谷 P2437. 蜜蜂路线](https://www.luogu.com.cn/problem/P2437)（dp+高精度）
[洛谷 P1130. 红牌](https://www.luogu.com.cn/problem/P1130) 
[洛谷 P1508. Likecloud-吃、吃、吃](https://www.luogu.com.cn/problem/P1508) 
[洛谷 P1002.过河卒](https://www.luogu.com.cn/problem/P1002) 
[力扣 62. 不同路径](https://leetcode.cn/problems/unique-paths/) 
[力扣 63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/) 
[力扣 64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/) 

## 区间 DP
所有的区间 dp 问题枚举时，第一维通常是枚举区间长度，并且一般 ${len = 1 }$ 时用来初始化，枚举从 ${len = 2 }$ 开始
第二维枚举起点 ${i }$ （右端点 ${j }$ 通过计算获得，${j = i + len - 1 }$）
[282. 石子合并](https://www.acwing.com/problem/content/284/) 


## 状态压缩 dp
[acwing 91. 最短Hamilton路径](https://www.acwing.com/problem/content/description/93/) 


## 卡特兰数
1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796,...

数学计算公式：
$$
\Large{ f\left( n \right) =\frac{1}{n+1} C_{2n} ^{n} }  
$$
递推式 1（推荐）：
$$
\Large{ f\left( n \right) =\frac{4n-2}{n+1} \times f\left( n-1 \right) ,\ f\left( 0 \right)=1  }
$$
- 时间复杂度：${O\left( n \right)  }$ 
- 空间复杂度：${O\left( 1 \right)  }$ 
```cpp
int f(int n) {
    int res = 1;
    for(int i = 1; i <= n; i++){
        res = 1ll * res * (4 * i - 2) / (i + 1); // 注意这三者顺序不能调换（防止爆int）
    }
    return res;
}
```

递推式 2：
$$
\Large{ F\left( n \right) =\displaystyle{\sum}\limits_{ k = 1 }^{ n } f\left( k-1 \right) f\left( n-k \right) },\ f\left( 0 \right) =1
$$
- 时间复杂度：${O\left( n^{2}  \right)  }$ 
- 空间复杂度：${O\left( n \right)  }$ 
```cpp
int f(int n){
	dp[0] = 1;
	for(int i = 1; i <= n; i++){
		for(int k = 1; k <= i; k++){
			dp[i] += dp[k - 1] * dp[i - k];
		}
	}
	return dp[n];
}
```


题目：
由 ${n }$ 个 ${+1 }$ 和 ${n }$ 个 ${-1 }$ 组成的 ${2n }$ 个数 ${a_{1} ,a_{2} ,\cdots ,a_{2n}  }$，其满足 $\forall k \in \left[ 1,2n \right] ，{a_{1} +a_{2} +\cdots +a_{k} \geq 0 }$ 的序列数
[洛谷 P1722 矩阵 II](https://www.luogu.com.cn/problem/P1722) 
[acwing 889. 满足条件的01序列](https://www.acwing.com/problem/content/description/891/) 

买票零钱问题
[洛谷 P1754 球迷购票问题](https://www.luogu.com.cn/problem/P1754) 

走方格：有一个大小为 n x n 的方格图左下角为 (0, 0) 右上角为 (n, n)，从左下角开始每次都只能向右或者向上走一单位，不走到对角线 y=x 上方（但可以触碰）的情况下到达右上角有多少可能的路径？

在圆上有 ${2n }$ 个点，用 ${n }$ 条线段连接起来 (每个点只能连一条线)，使所有的线段都不相交的方案数
[洛谷 P1976 鸡蛋饼](https://www.luogu.com.cn/problem/P1976) 
[洛谷 P1375 小猫](https://www.luogu.com.cn/problem/P1375) 

n 个数的出栈序列数
[洛谷 P1044 栈]( https://www.luogu.com.cn/problem/P1044 ) 
[acwing 415. 栈](https://www.acwing.com/problem/content/417/) 
[acwing 130. 火车进出栈问题](https://www.acwing.com/problem/content/132/) 

n 个点能构成多少种不同的二叉树
[力扣 96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/) 
[acwing 3691. 有向树形态](https://www.acwing.com/problem/content/3694/) 

n 对括号能有几种合法写法

# 贪心
## 区间问题
### 区间选点（最大不相交区间问题）
问题 1：给定 ${n }$ 个闭区间 ${\left[ l_{i} ,r_{i}  \right]  }$，在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点，求最小的点数
问题 2：给定 ${n }$ 个闭区间 ${\left[ l_{i} ,r_{i}  \right]  }$，选择尽量多的区间，使得选中的区间之间互不相交，求选取的区间数量

解法：首先将区间按右端点从小到大排序，依次遍历，区间能选取则选取
- 时间复杂度：${O\left( n\log n \right)  }$ 
```cpp
bool cmp(PII a, PII b){
    return a.second < b.second;
}
sort(ranges.begin(), ranges.end(), cmp); // 按右端点从小到大排序

int cnt = 0, end = -inf;
for(auto range : ranges){
    if(end <= range.first){ // 可以选
        end = range.second;
        cnt++;
    }
}
```

题目：
[acwing 905. 区间选点](https://www.acwing.com/problem/content/907/) 
[acwing 908. 最大不相交区间数量](https://www.acwing.com/problem/content/910/) 
[洛谷 P1803. 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803) 
[力扣 435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/description/) 
[力扣 646. 最长数对链](https://leetcode.cn/problems/maximum-length-of-pair-chain/) 
[力扣 3458. 选择 K 个互不重叠的特殊子字符串](https://leetcode.cn/problems/select-k-disjoint-special-substrings/) （区间合并 + 贪心）

### 区间分组
给定 ${n }$ 个闭区间 ${\left[ l_{i} ,r_{i}  \right]  }$，将这些区间分为若干组，使得组内的区间不重叠，求最小的组数

解法：首先将区间按左端点从小到大排序，依次遍历，若区间和某一组不冲突则加入该组，否则和所有组都冲突则单独开一组
只需要比对右端点最小的那一组即可，若与右端点最小的那一组都冲突，说明与所有组都冲突。找到右端点最小的那组可以使用堆来实现
- 时间复杂度：${O\left( n \log n \right)  }$ 
```cpp
sort(ranges.begin(), ranges.end()); // 左端点从小到大排序
priority_queue<int, vector<int>, greater<int>> q; // 用来存每一组右端点的最大值
for(auto range : ranges){
    if(!q.empty() && range.first > q.top()){ // 加入该组
        q.pop();
        q.push(range.second);
    }
    else{// 单开一组
        q.push(range.second);
    }
}
// q.size()即为答案
```

题目：
[acwing 906. 区间分组](https://www.acwing.com/problem/content/908/) 

### 区间覆盖
给定 ${n }$ 个闭区间 ${\left[ l_{i} ,r_{i}  \right]  }$ 以及一个区间 ${\left[ start,end \right]  }$，选择尽量少的区间，将指定线段区间完全覆盖, 求最少区间数量

解法：首先将区间按左端点从小到大排序，依次遍历，在所有能覆盖 ${start }$ 的区间中选择右端点最大的那个区间，更新 ${start }$ 到新位置。直到区间被完全覆盖或发现无解
- 时间复杂度：${O\left( n \log n \right)  }$ 
```cpp
sort(ranges.begin(), ranges.end()); // 左端点从小到大排序
for(int i = 0; i < n;){
    // 在所有左端点在start左边的区间中选择右端点最大的
    int j = i, maxR = -2e9;
    while(j < n && ranges[j].first <= start){
        maxR = max(maxR, ranges[j].second);
        j++;
    }
    // 没有左端点比start小的，或者最后一个区间都覆盖不完，无解
    if(j == i || j == n && maxR < end){
        ans = -1;
        break;
    }
    // 更新起点，记录答案
    ans++;
    if(maxR >= end) break; // 覆盖结束
    start = maxR;
    i = j;
}
```

题目：
[acwing 907. 区间覆盖](https://www.acwing.com/problem/content/909/) 

## 哈夫曼树
有 ${n }$ 个数，每个数为 ${a_{i}  }$，要经过 ${n-1 }$ 次两两合并至 ${1 }$ 堆。每次合并第 ${i }$ 个数和第 ${j }$ 个数的代价为 ${a_{i} +a_{j}  }$。求代价总和的最小值

解法：每次选取最小的两个数进行合并（使用堆进行选择）
- 时间复杂度：${O\left( n\log n \right)  }$ 
```cpp
priority_queue<int, vector<int>, greater<int>> q; // 使用小根堆
while(q.size() != 1){ // 每次选取最小的两个进行合并
    int a = q.top(); q.pop();
    int b = q.top(); q.pop();
    ans += a + b;
    q.push(a + b);
}
```

题目：
[acwing 148. 合并果子](https://www.acwing.com/activity/content/problem/content/1115/) 
[洛谷 P1090. 合并果子]( https://www.luogu.com.cn/problem/P1090 ) 

## 排序不等式
有 ${n }$ 个人排队到水龙头处打水，第 ${i }$ 个人装满水桶所需的时间是 ${t_{i}  }$，找到他们的打水顺序使所有人的等待时间之和最小

解法：按照 ${t_{i}  }$ 从小到大的顺序打水
所有人等待的总时间为
$$
\mathrm{time} =t_{1} \times \left( n-1 \right) +t_{2} \times \left( n-2 \right) +\cdots +t_{i} \times \left( n-i \right) +\cdots +t_{n} \times \left( n-n \right)  
$$
要使该式最小，则要有 ${t_{1} \leq t_{2} \leq t_{3} \leq \cdots \leq t_{n}  }$ 
- 时间复杂度：${O\left( n\log n \right)  }$ 
```cpp
sort(t, t + n); // 按照从小到大的顺序打水
LL time = 0;
for(int i = 0; i < n; i++){
    time += t[i] * (n - i - 1);
}
```

题目：
[acwing 913. 排队打水](https://www.acwing.com/problem/content/description/915/) 
[洛谷 P1223. 排队接水](https://www.luogu.com.cn/problem/P1223) 

## 绝对值不等式
已知 ${n }$ 个数 ${a_{1} \sim a_{n}  }$，求一个 ${x }$ 使得下式最小
$$
f\left( x \right)  =|a_{1} -x|+|a_{2} -x|+\cdots +|a_{n} -x|
$$
解法：当 ${x }$ 为 ${a_{1} \sim a_{n}  }$ 的中位数时结果最小
求中位数可以使用 [[#快速选择算法]] 
- 时间复杂度：${O\left( n \right)  }$ 
```cpp
int x = qselect(a, 0, n - 1, (n + 1) / 2); // 快速选择算法得到中位数
for(int i = 0; i < n; i++){
	ans += abs(a[i] - x);
}
```

题目：
[acwing 104. 货仓选址](https://www.acwing.com/problem/content/106/) 

## 局部交换法解决排序最值问题
该类问题为确认一个排序，使得目标函数取得最值（如上面的排序不等式）
通常的思考方法是固定一个顺序后，交换相邻两个值的顺序，再对交换前的函数值与交换后的函数值进行比较，最终得到一个排序条件

例题
[acwing 125. 耍杂技的牛](https://www.acwing.com/problem/content/description/127/) 
[洛谷 P1842. 奶牛玩杂技](https://www.luogu.com.cn/problem/P1842) 

|  | 交换前 | 交换后 |
| :--: | :--: | :--: |
| ${i }$ | ${W_{1}  +\cdots +W_{i-1} -S_{i}  }$ | ${W_{1} +\cdots +W_{i-1}+W_{i+1}  -S_{i}  }$ |
| ${i+1 }$ | ${W_{1}  +\cdots +W_{i-1}+W_{i}  -S_{i+1}  }$ | ${W_{1} +\cdots +W_{i-1} -S_{i+1}  }$ |
化简：

|  | 交换前 | 交换后 |
| :--: | :--: | :--: |
| ${i }$ | ${ -S_{i}  }$ | ${W_{i+1}  -S_{i}  }$ |
| ${i+1 }$ | ${W_{i}  -S_{i+1}  }$ | ${ -S_{i+1}  }$ |
只要找到条件使得下式成立即可
$$
\max\{ -S_{i} ,W_{i} -S_{i+1}  \} >\max\{ W_{i+1} -S_{i} ,-S_{i+1}  \} 
$$
若左边取 ${-S_{i}  }$，则该大于号肯定不成立
若左边取 ${W_{i} -S_{i+1}  }$，则右式肯定取 ${W_{i+1} -S_{i}  }$ 
则有
$$
W_{i} -S_{i+1} >W_{i+1} -S_{i} 
$$
即
$$
W_{i} +S_{i} >W_{i+1} +S_{i+1} 
$$
即满足上式条件后，交换后结果会变得更优
最终方案是：按照 ${W_{i} +S_{i}  }$ 从小到大排序

```cpp
struct COW{
    int W, S;
    bool operator < (const COW &a) const{
        return W + S < a.W + a.S;
    }
}cow[N];

sort(cow, cow + n); // 按照W + S从小到大排序
int ans = -inf, sum = 0;
for(int i = 0; i < n; i++){
	ans = max(ans, sum - cow[i].S);
	sum += cow[i].W;
}
```

题目：
[洛谷 P1012. 拼数](https://www.luogu.com.cn/problem/P1012) 

| 交换前 | 交换后 |
| :--: | :--: |
| ${\overline{s_{i}s_{j}}     }$ | ${\overline{s_{j} s_{i} }   }$ |
满足 ${\overline{s_{i}s_{j}}  >\overline{s_{j} s_{i} }    }$ 时交换后会变得更差，最终方案是：按照拼接后从大到小进行排序
```cpp
bool cmp(string s1, string s2){
	return s1 + s2 > s2 + s1;
}
```

[洛谷 P1094 [NOIP2007 普及组] 纪念品分组]( https://www.luogu.com.cn/problem/P1094 ) 

## 单步最优策略
每一步都选择最优的策略，即全局最优的解

题目：
[洛谷 P1208. 混合牛奶]( https://www.luogu.com.cn/problem/P1208 ) 
[洛谷 P1478. 陶陶摘苹果（升级版）](https://www.luogu.com.cn/problem/P1478) 
[洛谷 P4995. 跳跳！](https://www.luogu.com.cn/problem/P4995) 
[洛谷 P2240. 部分背包问题](https://www.luogu.com.cn/problem/P2240) 
[洛谷 P1106. 删数问题](https://www.luogu.com.cn/problem/P1106) 


## 贪心大杂烩
[洛谷 P3817. 小A的糖果](https://www.luogu.com.cn/problem/P3817) 
[acwing 1208. 翻硬币](https://www.acwing.com/problem/content/1210/) 
[acwing 1603. 整数集合划分](https://www.acwing.com/problem/content/1605/) 
[力扣 2834. 找出美丽数组的最小和](https://leetcode.cn/problems/find-the-minimum-possible-sum-of-a-beautiful-array/) 
[力扣 2864. 最大二进制奇数](https://leetcode.cn/problems/maximum-odd-binary-number/) 
[力扣 2789. 合并后数组中的最大元素](https://leetcode.cn/problems/largest-element-in-an-array-after-merge-operations/) 
[力扣 121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/) （线性 DP / 贪心 + 前缀最值）
[力扣 122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/) 
[力扣 55. 跳跃游戏](https://leetcode.cn/problems/jump-game/) 
[力扣 134. 加油站](https://leetcode.cn/problems/gas-station/) （前缀和 + 贪心）
[力扣 2740. 找出分区值](https://leetcode.cn/problems/find-the-value-of-the-partition/) 
[力扣 3111. 覆盖所有点的最少矩形数目](https://leetcode.cn/problems/minimum-rectangles-to-cover-points/) 
[力扣 605. 种花问题](https://leetcode.cn/problems/can-place-flowers/) 

# 数学
## 整除性质
设 ${a,b }$ 时两个整数且 ${a\neq 0 }$，如果存在另一个整数 ${q }$ 使得 ${b=aq }$，则说 ${b }$ 可以被 ${a }$ 整除，记作 ${a|b }$，且称 ${b }$ 是 ${a }$ 的倍数，${a }$ 是 ${b }$ 的约数
常用性质：
12. 若 ${a|b }$ 且 ${b|c }$，那么 ${a|c }$ 
13. 若 ${a|b }$ 且 ${a|c }$，那么对任意的整数 ${x,y }$，有 ${a|bx+cy }$ 
14. 设整数 ${m\neq 0 }$，那么 ${a|b }$ 等价于 ${ma|mb }$ 


## 取模运算性质
### 运算规则
15. 加： $(a + b) \% p = (a \% p + b \% p) \% p$ 
16. 减：$(a - b) \% p = (a \% p - b \% p ) \% p$ 
17. 乘：$(a * b) \% p = (a \% p * b \% p) \% p$ 
18. **没有除法！** 
19. 幂指： $( a ^ b ) \% p = ((a \% p)^b) \% p$ 


## 同余
若两数 ${x,y }$ 除以 ${b }$ 的余数相等，则称 ${x,y }$ 在模 ${b }$ 意义下同余，记作 ${x\equiv y\left( \mod b \right)  }$ 

- 自反性：${x\equiv x\left( \mod{M}  \right)  }$ 
- 对称性：若 ${x\equiv y\left( \mod{M}  \right)  }$ ，则 ${y\equiv x\left( \mod{M}  \right)  }$ 
- 传递性：若 ${x\equiv y\left( \mod{M}  \right) }$，${y\equiv z\left( \mod{M}  \right)  }$，则 ${x\equiv z\left( \mod{M}  \right)  }$ 
- 同加性：若 ${x\equiv y\left( \mod{M}  \right)  }$，则 ${x+z\equiv y+z\left( \mod{M}  \right)  }$ 
- 同乘性：若 ${x\equiv y\left( \mod{M}  \right)  }$，则 ${x \times z\equiv y \times z\left( \mod{M}  \right)  }$ 
- 同幂性：若 ${x\equiv y\left( \mod{M}  \right)  }$，则 ${x^{n} \equiv y^{n} \left( \mod{M}  \right)  }$ 
- **重要性质**： ${x\equiv y\left( \mod{M}  \right) \leftrightarrow M|\left( x-y \right)  }$ 

## 算术基本定理
任意一个正整数 ${n }$ 都可以写成所有质数的指数次方的乘积。（质数有无穷多个）
$$
\Large{ n=p_{1} ^{k_{1} } p_{2} ^{k_{2} } p_{3} ^{k_{3} } \cdots  \quad \left( p表示质数 \right)  }
$$

## 质数
### 质数定理
$1\sim n$ 中间大约有 $\Large{ \frac{n}{ln^n} }$ 个质数
该定理用来估计时间复杂性

${1\sim 10^{4}  }$ 中有 ${1229 }$ 个质数，数量级为 ${10^{3}  }$ 
${1\sim 10^{5}  }$ 中有 ${9592 }$ 个质数，数量级为 ${10^{4}  }$ 


### 判断质数
判断一个数 ${x }$ 是否是质数

- 时间复杂度：${O\left( \sqrt{ n }  \right)  }$ 
```cpp
bool is_prime(int x) {
	if (x < 2)return false;
	for (int i = 2; i <= x / i; i++) // 写成i * i <= x可能爆int
		if (x % i == 0) return false;
	return true;
}
```

题目：
[acwing 866. 试除法判定质数](https://www.acwing.com/problem/content/868/) 
[洛谷 P1304. 哥德巴赫猜想](https://www.luogu.com.cn/problem/P1304) 
[洛谷 P2640. 神秘磁石](https://www.luogu.com.cn/problem/P2640) 
[洛谷 P1579. 哥德巴赫猜想（升级版）](https://www.luogu.com.cn/problem/P1579) 
[洛谷 P1125. 笨小猴]( https://www.luogu.com.cn/problem/P1125 ) 
[洛谷 P1217. 回文质数]( https://www.luogu.com.cn/problem/P1217 ) 

### 质因数分解
根据算术基本定理，将一个数的质因子及其次数分解出来

- 时间复杂度：${O\left( \sqrt{ n }  \right)  }$ 
```cpp
vector<PII> divide(int x){
    // 分解质因数
    vector<PII> factor;
    for(int p = 2; p <= x / p; p++){
        if(x % p == 0){ // if成立时p一定是质数
            int k = 0;
            while(x % p == 0){
                x /= p;
                k++;
            }
            factor.push_back({p, k});
        }
    }
    if(x > 1) factor.push_back({x, 1});
    return factor;
}
```

题目：
[acwing 867. 分解质因数](https://www.acwing.com/problem/content/869/) 
[洛谷 P1075. 质因数分解](https://www.luogu.com.cn/problem/P1075) 
[acwing 1381. 阶乘](https://www.acwing.com/problem/content/1383/) 
[acwing 449. 质因数分解](https://www.acwing.com/problem/content/description/451/) 

### 质数筛
求出 ${1\sim n }$ 中所有的质数

该筛法确保了每一个合数都只被它最小的质因数筛掉
- 时间复杂度：${O\left( n \right)  }$ 
```cpp
bool st[1000010]; // st[i] = true表示被筛掉
vector<int> get_primes(int n){
    // 质数筛
    vector<int> primes;
    for(int i = 2; i <= n; i++){
        if(!st[i]){
            primes.push_back(i);
        }
        for(int j = 0; primes[j] <= n / i; j++){
            st[primes[j] * i] = true;
            if(i % primes[j] == 0) break;
        }
    }
    return primes;
}
```

题目：
[acwing 868.筛质数](https://www.acwing.com/problem/content/870/) 
[洛谷 P5723. 质数口袋](https://www.luogu.com.cn/problem/P5723) 
[洛谷 P5736. 质数筛](https://www.luogu.com.cn/problem/P5736) 
[力扣 204. 计数质数](https://leetcode.cn/problems/count-primes/)

## 约数
记 $a=p_1^{\alpha_1} p_2^{\alpha_2} p_3^{\alpha_3} \dots ，b = p_1^{\beta_1} p_2^{\beta_2} p_3^{\beta_3} \dots$ 

- 最大公约数：$\mathrm{gcd} (a,b) = p_1^{min(\alpha_1,\beta_1)} p_2^{min(\alpha_2,\beta_2)} p_3^{min(\alpha_3,\beta_3)} \dots$ 

- 最小公倍数：$\mathrm{lcm} (a,b) = p_1^{max(\alpha_1,\beta_1)} p_2^{max(\alpha_2,\beta_2)} p_3^{max(\alpha_3,\beta_3)} \dots$ 

-  ${a }$ 的约数个数：$\tau \left( a \right)   = (\alpha_1 + 1)\times (\alpha_2+1)\times (\alpha_2+1)\dots$    

- ${a }$ 的约数之和：$\sigma \left( a \right)   = (p_1^0+p_1^1+\dots+p_1^{\alpha_1})\times\dots\times(p_k^0+p_k^1+\dots+p_k^{\alpha_k})$ 


### 最大公约数 gcd
- 时间复杂度：${O\left( \log \max\{ a,b \}  \right)  }$ 
```cpp
int gcd(int a,int b){
    return b ? gcd(b, a % b) : a;
}
```

题目：
[acwing 872. 最大公约数](https://www.acwing.com/problem/content/874/) 
[洛谷 P1888. 三角函数](https://www.luogu.com.cn/problem/P1888) 
[力扣 1979. 找出数组的最大公约数](https://leetcode.cn/problems/find-greatest-common-divisor-of-array/) 

### 最小公倍数 lcm
$$
\mathrm{lcm} \left( a,b \right) =\frac{a\times b}{\mathrm{gcd} \left( a,b \right) } 
$$
- 时间复杂度：${O\left( \log \max\{ a,b \}  \right)  }$ 
```cpp
int lcm(int a, int b){
	reutrn a / gcd(a, b) * b;
}
```


## 常用公式化简
### 两两相乘求和
已知长度为 ${n }$ 的序列 ${a_{1} \sim a_{n}  }$，求其两两相乘后的求和结果
$$
\begin{align} S&=a_{1} \cdot a_{2} +a_{1} \cdot a_{3} +\cdots +a_{1} \cdot a_{n} \\&+a_{2} \cdot a_{3} + a_{2} \cdot a_{4} +\cdots +a_{2} \cdot a_{n} \\&+\cdots \\&+a_{n-2} \cdot a_{n-1} +a_{n-2} \cdot a_{n} \\&+a_{n-1} \cdot a_{n} \end{align} 
$$
提取公因式后该式可以化为
$$
\begin{align} S&=\left( a_{1}  \right)\cdot a_{2} \\&+\left( a_{1} +a_{2}  \right) \cdot a_{3} \\&+\left( a_{1} +a_{2} +a_{3}  \right) \cdot a_{4} \\&+\cdots \\&+\left( a_{1} +a_{2} +\cdots +a_{n-1}  \right) \cdot a_{n}   \end{align} 
$$
- 时间复杂度：${O\left( n \right)  }$ 
```cpp
int S = 0; // 存储结果
int presum = 0; // 前缀和
for(int i = 1; i <= n; i++){
	presum += a[i - 1];
	S += presum * a[i];
}
```


## 组合数
性质：
$$
C_{n} ^{0} +C_{n} ^{1} +C_{n} ^{2} +\cdots +C_{n} ^{n} =2^{n} 
$$


计算公式：
$$
\Large{ C_{n} ^{m} =\frac{n!}{m!\left( n-m \right) !}  }
$$
递推式：
$$
\Large{ C_{n} ^{m} =C_{n-1} ^{m} +C_{n-1} ^{m-1}  }
$$
$$
\Large{ 当m=0时，C_{n} ^{m} =1 }
$$


预处理组合数：当数据范围 ${0\leq m\leq n\leq 2000 }$ 时，可以使用递推式将所有组合数预处理出来
- 时间复杂度：${O\left( n^{2}  \right)  }$ 
- 空间复杂度：${O\left( n^{2}  \right)  }$ 
```cpp
const int N = 2001, MOD = 1e9+7;
int C[N][N];

for(int i = 0; i <= 2000; i++){
    for(int j = 0; j <= i; j++){
        if(j == 0) C[i][j] = 1;
        else C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
    }
}
```



## 推导数学公式
[力扣 2575. 找出字符串的可整除数组](https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/) 
[力扣 3128. 直角三角形](https://leetcode.cn/problems/right-triangles/) 



# 数据结构设计
[力扣 232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/) 
[力扣 225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/) 
[力扣 641. 设计循环双端队列](https://leetcode.cn/problems/design-circular-deque/) 
[力扣 155. 最小栈](https://leetcode.cn/problems/min-stack/) 
[力扣 2296. 设计一个文本编辑器](https://leetcode.cn/problems/design-a-text-editor/) （双向链表/栈）
[力扣 2671. 频率跟踪器](https://leetcode.cn/problems/frequency-tracker/) （双哈希表）
[力扣 380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/) （哈希表 + 数组尾部交换）
[力扣 381. O(1) 时间插入、删除和获取随机元素 - 允许重复](https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/) （哈希表套集合 + 数组尾部交换）
[力扣 895. 最大频率栈](https://leetcode.cn/problems/maximum-frequency-stack/) （哈希表套栈）
[力扣 146. LRU 缓存](https://leetcode.cn/problems/lru-cache/) （双向链表 + 哈希表）
[力扣 432. 全 O(1) 的数据结构](https://leetcode.cn/problems/all-oone-data-structure/) （双向链表套集合+ 哈希表）
[力扣 295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/) （对顶堆）
[力扣 2080. 区间内查询数字的频率](https://leetcode.cn/problems/range-frequency-queries/) （哈希表 + 二分）
[力扣 2502. 设计内存分配器](https://leetcode.cn/problems/design-memory-allocator/) 
[力扣 1472. 设计浏览器历史记录](https://leetcode.cn/problems/design-browser-history/) 
[力扣 2353. 设计食物评分系统](https://leetcode.cn/problems/design-a-food-rating-system/) (哈希表+有序集合)

# 链表
## 反转链表
循环版本
```cpp
ListNode* reverseList(ListNode* head) {
    if(head == nullptr) return nullptr;
    ListNode *a = head, *b = head->next;
    while(b != nullptr){
        ListNode *c = b->next;
        b->next = a;
        a = b;
        b = c;
    }
    head->next = nullptr;
    return a;
}
```
递归版本
```cpp
ListNode* reverseList(ListNode* head) {
	if(head == nullptr || head->next == nullptr) return head;
	ListNode* tail = reverseList(head->next);
	head->next->next = head;
	head->next = nullptr;
	return tail;
}
```
[力扣 206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/) 
[力扣 234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/) 
[力扣 25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/) 
```cpp
ListNode* reverseKGroup(ListNode* head, int k) {
    ListNode *t = new ListNode(-1), *r = t;
    t->next = head;

    while(r->next != nullptr){
        // 判断r后面是否还有k个结点
        int cnt = 0;
        for(ListNode *p = r->next; p != nullptr && cnt < k; p = p->next) cnt++;
        if(cnt < k) break;

        // 翻转r后面的k个结点
        ListNode *a = r->next, *b = a->next;
        for(int i = 1; i < k; i++){ // 只需要修改k-1个指针
            ListNode *c = b->next;
            b->next = a;
            a = b;
            b = c;
        }

        // 处理局部链表首尾结点处的连接情况
        ListNode *q = r->next;
        r->next = a;
        q->next = b;
        r = q;
    }
    return t->next;
}
```

## 其他
创建虚拟头结点
[力扣 21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/) 
[力扣 2. 两数相加](https://leetcode.cn/problems/add-two-numbers/) 
[力扣 86. 分隔链表](https://leetcode.cn/problems/partition-list/) 
[力扣 160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/) 
[力扣 19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) 
[力扣 138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)（克隆图 / 哈希表）
```cpp
// O(1)空间复杂度做法
Node* copyRandomList(Node* head) {
    // 复制节点：A -> B 变成 A -> A' -> B
    for(Node *p = head; p != NULL; p = p->next->next){
        Node *t = new Node(p->val);
        t->next = p->next;
        p->next = t;
    }
    // 拷贝random指针
    for(Node *p = head; p != NULL; p = p->next->next){
        if(p->random == NULL) p->next->random = NULL;
        else p->next->random = p->random->next;
    }
    // 拆分链表
    Node* t = new Node(-1), *r = t;
    for(Node* p = head; p != NULL; p = p->next){
        r->next = p->next;
        r = r->next;
        p->next = p->next->next;
    }
    return t->next;
}
```
[力扣 142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/) （哈希表 / 快慢指针）
[力扣 148. 排序链表](https://leetcode.cn/problems/sort-list/) （链表的非递归归并排序）
```cpp
// 链表的非递归归并排序
ListNode* sortList(ListNode* head) {
    int n = 0;
    // 求链表长度
    for(ListNode* p = head; p != nullptr; p = p->next) n++;

    ListNode *t = new ListNode(-1), *r = t;
    r->next = head;
    ListNode *p1, *p2;

    for(int len = 1; len < n; len *= 2){ // 枚举归并区间长度
        r = t;
        // 归并[i, i+len]和[j, j+len]区间
        for(int i = 0, j = i + len; j < n; i += len, j += len){
            p1 = r->next;
            p2 = r->next;
            for(int i = 0; i < len; i++) p2 = p2->next;

            int a = i + len, b = min(j + len, n);
            while(i < a && j < b){
                if(p1->val <= p2->val){
                    r->next = p1;
                    r = r->next;
                    p1 = p1->next;
                    i++;
                }
                else{
                    r->next = p2;
                    r = r->next;
                    p2 = p2->next;
                    j++;
                }
            }
            // 扫尾
            while(i < a){
                r->next = p1;
                r = r->next;
                p1 = p1->next;
                i++;
	        }
            while(j < b){
                r->next = p2;
                r = r->next;
                p2 = p2->next;
                j++;
            }
            r->next = p2;
        }
    }
    return t->next;
}
```


# 树
## 二叉树
### 遍历
[力扣 144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/) （dfs）
[力扣 94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/) （dfs）
[力扣 145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/) （dfs）
[力扣 102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/) （bfs）
[力扣 103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/) (bfs)
[力扣 113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/) （dfs）
[力扣 938. 二叉搜索树的范围和](https://leetcode.cn/problems/range-sum-of-bst/)（dfs）
[力扣 1261. 在受污染的二叉树中查找元素](https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree/) （dfs + 哈希表）

### 递归
[力扣 104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) （递归）
[力扣 111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/) （递归）
[力扣 543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/) 
[力扣 1026. 节点与其祖先之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/) （递归）
[力扣 110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/) （递归）
[力扣 98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/) (dfs / 递归)
[力扣 662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/) (bfs + 结点编号)
[力扣 222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/) （递归※）
[力扣 958. 二叉树的完全性检验](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/) （递归 + 结点编号）
[力扣 669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/) （递归）
[力扣 572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/) （递归）

[力扣 105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) （递归）
[力扣 106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) (递归)
[力扣 297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/) （dfs + 共享变量递归建树）

[力扣 2673. 使二叉树所有路径值相等的最小代价](https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/) （贪心 + 递归）

### 最近公共祖先
[力扣 236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) 
[力扣 235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/) 


## 一般的树
### 遍历
[力扣 2368. 受限条件下可到达节点的数目](https://leetcode.cn/problems/reachable-nodes-with-restrictions/) 



# 综合题
[力扣 2867. 统计树中的合法路径数目](https://leetcode.cn/problems/count-valid-paths-in-a-tree/) （并查集 + 搜索 + 素数筛 + 两两相乘求和）



# 不好分类的题目

## 归并
[力扣 88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/) （逆序遍历数组）

## 数组轮转
[力扣 189. 轮转数组](https://leetcode.cn/problems/rotate-array/) （数组翻转）

## 数组跳跃
[力扣 45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/) 

## 前后缀数组
[力扣 238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/) 

## 丑数
[力扣 264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/) 



# 目标题单

博弈
[洛谷 P4702. 取石子](https://www.luogu.com.cn/problem/P4702) 

带权并查集
给你一张带边权的图，为每个点分为两类中的一类，使得两类中边权最大值最小
[洛谷 P1525. 关押罪犯](https://www.luogu.com.cn/problem/P1525) 
![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202408162302937.png)


两边收缩双指针
[力扣 1574. 删除最短的子数组使剩余数组有序](https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/) 

[力扣 378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/) （二分+双指针）
[力扣 786. 第 K 个最小的质数分数](https://leetcode.cn/problems/k-th-smallest-prime-fraction/) （二分+双指针）

## 单调栈

https://www.bilibili.com/video/BV1GH4y1D7TB/?spm_id_from=333.999.0.0&vd_source=8d7f908023978738eea1c059f8f778cc 

[牛客 大雨吃小鱼](https://www.nowcoder.com/practice/77199defc4b74b24b8ebf6244e1793de) 
[力扣 2289. 使数组按非递减顺序排列](https://leetcode.cn/problems/steps-to-make-array-non-decreasing/) 
[力扣 1504. 统计全 1 子矩形](https://leetcode.cn/problems/count-submatrices-with-all-ones/) 


## 并查集
[力扣 2421. 好路径的数目](https://leetcode.cn/problems/number-of-good-paths/) 
[力扣 928. 尽量减少恶意软件的传播 II](https://leetcode.cn/problems/minimize-malware-spread-ii/) 

## flood fill
[力扣 803. 打砖块](https://leetcode.cn/problems/bricks-falling-when-hit/) 



## 线段树
[acwing 245. 你能回答这些问题吗](https://www.acwing.com/problem/content/246/) 
[3165. 不包含相邻元素的子序列的最大和](https://leetcode.cn/problems/maximum-sum-of-subsequence-with-non-adjacent-elements/) 

## 图论

### 拓扑排序
[力扣 2127. 参加会议的最多员工数](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/) 

## 搜索
### bfs
[力扣 691. 贴纸拼词](https://leetcode.cn/problems/stickers-to-spell-word/) 
[力扣 126. 单词接龙 II](https://leetcode.cn/problems/word-ladder-ii/) 

### 双向广搜
[力扣 127. 单词接龙](https://leetcode.cn/problems/word-ladder/) 
[力扣 1755. 最接近目标值的子序列和](https://leetcode.cn/problems/closest-subsequence-sum/) 

### dijkstra
[力扣 LCP 35. 电动车游城市](https://leetcode.cn/problems/DFPeFJ/) 

## 堆技巧
删除任意一个元素：
再维护另一个堆，将要删除的元素加入该堆。当两个堆堆顶相同时则同时弹出

行有序数表第 k 大
![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202408162236093.png)

![image.png](https://ged-pic-bed.oss-cn-guangzhou.aliyuncs.com/img/202408162240163.png)


## 动态规划
分类以及题单 https://leetcode.cn/circle/discuss/tXLS3i/ 

## 组合数
[3179. K 秒后第 N 个元素的值](https://leetcode.cn/problems/find-the-n-th-value-after-k-seconds/) 